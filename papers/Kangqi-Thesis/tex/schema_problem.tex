%# -*- coding: utf-8-unix -*-
% !TEX program = xelatex
% !TEX root = ../thesis.tex
% !TEX encoding = UTF-8 Unicode

\subsection{任务定义}
\label{sec:schema-problem}

%In this section, we first give formal definitions of the knowledge base
%and the schema graph, then describe the paraphrasing task.

%TODO: definition的样式没了，不过不一定需要。
\begin{definition}

在本章中，我们定义知识库为$KB=\{E, L, P\}$三部分组成，具体如下：
$E$为知识库$KB$中所有实体集合；
$L$为$KB$中所有不同谓词的集合;
%  All the entities, types and predicate names in $KB$ are identified by a unique id.
$P$为$KB$中所有事实三元组集合，
每一个三元组表示为$p(e_1, e_2)$，其中$e_1, e_2 \in E$，并且$p \in L$.
此外，知识库中存在用于描述一个实体所拥有类型的谓词$IsA$，
为了简化描述，本章中我们将不同类型也看做实体，同属于集合$E$中。

\end{definition}

%\KQ{Add some sentences showing what's a schema: abstraction}

%1. relation comes from a detail subgraph (give an example of mo_of)
%A knowledge base is capable of representing complex relations
%between real entities.
%As what we've shown in \figref{fig:fb-schema}, though there is no
%direct grandfather relation between ``Pactrick Schwarzenegger''
%and ``Gustav Schwarzenegger'', they can be indirectly connected via
%the ``parent + parent + male'' structure.
%2. relation schema is a summarization o a list of subgraphs. (by substitution)
%Intuitively, different instances of a complex relation type share a
%common structure (the schema), which is the template of that relation.
%Now we give the formal definition of a schema graph.


%3. formal def. of S
\begin{definition}


一个模式图$S$同样由三部分构成，$S=\{E_S, X, P_S\}$，具体如下：
$E_S \subseteq E$，为模式图中出现的具体的实体集合；
$X$为实体变量的集合，每一个变量$x \in X$在模式图中等同于占位符，
为特定实体$e \in E$的抽象；
模式图中包含两个特殊变量，即$x_{subj}, x_{obj} \in X$，
分别代表目标关系的主语和宾语实体；
$P_S$为模式图中的抽象三元组集合，每一个抽象三元组为$p_s(v_1, v_2)$，
其中$v_1 \in X$ ， $v_2 \in E_S \cup X$ 以及 $p_s \in L$。
此外，模式图$S$具有以下性质：
\begin{itemize}
  \item $S$的表现形式为有向树形结构，且根节点一定为主语的实体变量$x_{subj}$；
  \item 连接主语变量$x_{subj}$和宾语变量$x_{obj}$的谓词路径，称为模式图$S$的骨架；
  \item 骨架之外的所有抽象三元组称为模式图的限制（或分支）；
  \item 一个仅具有骨架而不包含任何限制的模式图，称为简单模式图，等价于谓词路径。
%   \KZ{How do you ensure that
%	all nodes internal nodes are variables and all external nodes are
%	are constants or $x_1$ or $x_2$. Also how do we say that there's no
%	two consecutive variable nodes in the tree. These are not clear now.}
%  \item On the path from $x_1$ to $x_2$ (which is the skeleton
%        of $S$), all vertices $v \in X$.
%  \item In the tree, all non-leaf vertices $v \in X$.
%  \item[-] $c = \text{solid}$, if and only if $v_1, v_2 \in X$, $p_s \in L$,
%  \item[-] $c = \text{dashed}$, if and only if $v_1 \in X, v_2 \in E'$, $p_s \in L$,
%  \item[-] $c = \text{isa}$, if and only if $v_1 \in X, v_2 \in T'$ and $p_s = \text{isa}$.
\end{itemize}
%\KZ{I think the input $e_1$ and $e_2$ should be separated from E'. These
%are the target entities, different from other concrete entities in the
%schema.}
  %These restrictions make every predicate in $S$ connecting to at least one variable.
  %Generalize the definition. We do not need the graph to be a tree.

  %\item[*] All $solid$ predicates form a tree, where both $x_{subj}$ and $x_{obj}$ must
  %be a leaf, that is, linked by only one $solid$ predicate.
\end{definition}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\columnwidth]{figure/schema/problem.eps}
    \bicaption{模式图的一般形式。}{A general style of a schema graph.}
    \label{fig:schema-problem}
\end{figure}


\figref{fig:schema-problem}显示了模式图的一般形式。
%可以讲一下E_S, X, P_S分别是啥。
可以发现，其中的每一条边都至少连接了一个实体变量。
模式图代表着知识库中，满足相同特定结构的一系列具体子图。
这些具体子图称为实例图（Grounded Garph），作为模式图的实例化形式，
所有的实体变量$x_i$被替换为特定的实体$e_i \in E$，
且每一个抽象三元组$p_s(v_1, v_2)$在实例化之后均对应
存在于知识库中的事实$p(e_1, e_2) \in P$。
例如\figref{fig:schema-intro}中的模式图，
其不同的实例图囊括了知识库中所有已知的（个人，双亲，双亲父亲）知识。
对于实例图中的主宾语对$(e_{subj}, e_{obj})$，
我们称其为模式图的一个支持实例。
%我们称该实体对支持当前的模式图。%TODO: 换个说法？
%If a ground graph of $S$ instantiates $x_{subj}$ to $e_{subj}$ and $x_{obj}$ to
%$e_{obj}$, then $S$ is said to {\em cover} the entity pair 



根据以上符号定义，
给定知识库$KB$，自然语言关系$r$以及多个关系三元组\{($e_{subj}$, $r$, $e_{obj}$)\}，
我们对关系的深度语义挖掘任务为，
推导出一系列描述其语义的候选模式图，并学习模式图上的概率分布，
以此表示自然语言关系所具有的多义性。
%induce a list of schemas and the probability distribution over the schemas, such that observed instances
%can be produced with the highest probability.

%find a ranked list of schemas that have the most similar meaning
%to $r$. \KZ{Why isn't the problem one that finds a list of schemas
%that {\em collectively cover} as many input pairs as possible?}

%The weight of each schema represents the fitness score over inputs.
%Intuitively, schema fits input entity pairs properly, if neither too general
%(producing too many coverages),
%nor too specific (only covers a few positive pairs).

%It's clear that output schemas could be selected from any schema covered at least one entity pair.
%However, existing knowledge base could have millions of entities and thousands of different
%kinds of predicates, leading to a huge search space.
%The searching direction is crucial for finding more suitable schemas within
%limit time and space.
%In addition, with no labeled schemas as training data, we need a
%data-driven metric to label each schema with a ``silver'' score, measuring
%the quality of one candidate schema.
%Therefore, we define a function $cost(EP, S)$, measuring the cost of one schema $S$
%with respect to positive input pairs $EP$, and then perform a local search algorithm guided by this function.
%\KZ{Shall we give a more formal def of the paraphrasing problem? You can
%refer to the way it's defined in Gong yu's paper. It's similar.}

%Next, we present an overview of the framework (\secref{sec:approach}),
%and explain how candidate schemas are generated (\secref{sec:candgen}),
%and how the schema probability is computed based on relation instances (\secref{sec:schema}).
%

%and how the silver score is computed to train the classifier for
%schema inference.

%how we obtain the cost function based on the view of information theory (\secref{sec:scoring}),
%and how the local searching process is performed (\secref{sec:candidate}).

%In section 3, we focus on how we build th   based on the view of information theory.
%
%For the local searching algorithm,
%
%Output schemas are chosen from a set of \textit{candidate schemas} in KB,
%which are the most suitable (neither too general nor too specific) for the given data.
%
%In order to describe all given entity pairs, the hit pairs of output schemas
%must cover all the given entities.
%Furthermore, we build a cost function to measure the fitness score over a schema and entity pairs,
%turning our task to an optimization problem.
%%2. bridge the gap bet. entity and schema. that's assign
%%A ground graph bridges the gap between $\langle e_{subj}, e_{obj} \rangle$ and a schema.
%%All schemas that can hit at least one entity pair form the schema searching space.
%%Each entity pair is assigned to at least one schema which hits the pair.
%%After the step of assignment, a cost is produced when a schema is selected
%%to describe all its assigned entity pairs assigned.
%%%3. Goal: Min Cost
%%With cost function provided, we look for a set of schemas describing
%%all entity pairs at a minimum cost.
%
%%4. Formally Define.
%The following is the formal definition of our task.
%
%\begin{definition}[The Paraphrasing Problem]
%\label{def:pp}
%Given $KB$, entity pairs $EP = \{ep_1, ..., ep_n\}$,
%a cost function $f: EP \times S \rightarrow [0, +\infty)$,
%and a function $sel$ that selects all candidate schemas ($CS$) from $KB$,
%return a set of output schemas $OS \subseteq CS$, such that:
%\begin{itemize}
%    \item[-] $EP \subseteq \bigcup_{S \in OS} HP(S)$,
%    \item[-] Whole cost $Z = \sum\nolimits_{S \in OS} f(EP, S)$ is minimum.
%\end{itemize}
%%
%%Given $KB$, a binary relation pattern $rel$ with its support entity pairs
%%$EP = \{ ep_1, ..., ep_n \}$, cost function $f$ and $g$,
%%Let $CS = \{S | EP \cap HP(S) \neq \emptyset \}$ be \textit{candidate schemas} and
%%$DS = \{S_1, ..., S_m\} \subseteq CS$ be a set of \textit{selected schemas}.
%%Let $Ass_{m \times n}$ be an 0/1 \textit{assignment matrix} from $EP$ to $DS$ and
%%\textit{support set} $sup(S_j) = \{ep_i | Ass_{ij} = 1\}$ be all entity pairs assigned to the $j$-th schema.
%%The assignment $Ass$ is a valid assignment over $EP$ and $SG$ if it satisfies the following
%%constraints:
%%\begin{itemize}
%%    \item[-] $Ass_{ij} = 1 \Rightarrow ep_i \in HP(S_j)$,
%%    \item[-] $\forall ep_i \in EP, \exists S_j \in DS, Ass_{ij} = 1$,
%%    \item[-] $\forall S_j \in DS, \exists ep_i \in EP, Ass_{ij} = 1$,
%%\end{itemize}
%\end{definition}
%
%%The selected schemas $DS$ and corresponding $Ass$ are optimal, if it minimizes
%%the cost $Z(DS, Ass) = \sum\nolimits_{S \in DS} f(S) + g(S, sup(S))$ , where $f$ is a
%%cost function over a specific schema, and $g$ is a cost function over a schema along
%%with its support set. Both $f$ and $g$ are non-negative functions and defined by users.
%
%%Now we define the task of paraphrasing between NL and KB. Given KB, a binary relation
%%pattern $rel$ with its support entity pairs
%%$EP = \{\langle e_1^{(1)}, e_2^{(1)} \rangle , ..., \langle e_1^{(n)}, e_2^{(n)} \rangle \}$
%%from KB, we want to find a set of relation schemas $\vec{S}$ that:
%%
%%\begin{itemize}
%%    \item[-] Each entity pair is hit by at least one schema in $\vec{S}$,
%%    \item[-] The schemas fits $EP$ at the best (neither too general nor too specific).
%%\end{itemize}
%%
%%where the score of fitness is produced by a cost function $Cost(EP, \vec{S})$.
%%The cost function captures both compactness and precision for the set of schemas to describe the entity pairs.
%
%
%%\KQ{The reason of restricting at most K relation schemas is to avoid generating too many schemas.
%%In the formula, Cost(EP|S) is the dominant one,
%%probably 5~10 pairs hit by one specific schema could bring that schema into description set.}
%%
%%Next, we prove that the paraphrasing problem is NP-Hard.
%%We show that by constraining $sel$ and $f$ to some specific classes of
%%functions, the resulting instance of the paraphrasing problem can
%%be reduced from the well-known {\em weighted set cover problem},
%%which is NP-complete.
%%
%%\begin{theorem}
%%Given $KB$, $EP$, candidate selecting function $sel$ and cost function $f$,
%%computing the optimal output schemas for describing all pairs in $EP$, is NP-Hard.
%%\end{theorem}
%%
%%\begin{proof}
%%%Rephrase that a simplified instance of our problem is still NP-Hard.
%%We first state the simplified instance of the paraphrasing problem.
%%The function $sel$ is restricted by only returning a special kind
%%of schema, which has only $x_{subj}$ and $x_{obj}$ connected by a solid
%%predicate. In addition, the cost function $f$ is simplified as
%%$g: S \rightarrow [0, \infty)$, that is,
%%the cost is only determined by the schema, and not by EP.
%%
%%After the simplification, the \textbf{decision version} of the
%%paraphrasing problem is as follows:
%%Given $KB$, $EP$, $sel$, $g$ and a threshold $\theta$, is there a set of output schema $OS$
%%covering all pairs in $EP$, such that whole cost $Z \leq \theta$ ?
%%The proof relies on a reduction from \textsc{Weighted Set Cover} problem:
%%Given a universe $U = \{u_1, ..., u_n\}$, a threshold $\theta$, a set $V = \{v_1, ..., v_m\}$
%%whose union equals to $U$, each $v_j \subseteq U$ and a weight set $W = \{w_1, ..., w_m\}$ assigned to each $v_j$,
%%is there a cover $C \subseteq V$ whose union equals to $U$, and the summation weight is no larger than $\theta$ ?
%%
%%\textit{Reduction:} For an arbitrary instance of \textsc{Weighted Set Cover} problem,
%%we build a $KB$ based on $U$ and $V$, where it contains only $m$ different predicates $p_1, ..., p_m$,
%%leading to a set $m$ simple candidate schemas.
%%We map each $u_i$ to an entity pair $ep_i = \langle e_{subj}^{(i)}, e_{obj}^{(i)} \rangle $.
%%For any $u_i$ and $v_j$, if $u_i \in v_j$, we add a predicate instance $p_i(e_{subj}^{(i)}, e_{obj}^{(i)})$ into $KB$.
%%Finally, we define the cost function as $g(S_j) = w_j$ for each schema.
%%
%%Since all schemas have only one edge, retrieving candidate schemas from $KB$
%%along with hit pairs can be done in polynomial time. Therefore, the paraphrasing decision problem
%%is formulated as: Given $n$ entity pairs and $m$ sets of hit pairs whose union cover all pairs,
%%with the weight $w_j$ assigned to the $j$-th set, can I pick some sets that still cover all
%%the entity pairs, satisfying the summation weight no larger than $\theta$ ?
%%Obviously, solving this paraphrasing decision problem is equivalent to
%%solving the corresponding \textsc{Weighted Set Cover} problem.
%%\end{proof}
%%
%%%In this reduction, $U$ and $V$ are used to construct a $KB$,
%%%where $m$ different predicates $p_1, ..., p_m$ are in $KB$,
%%%each $u_i$ indicates an entity pair $\langle e_1^{(i)}, e_2^{(i)} \rangle $,
%%%and the relation instance $p_i(e_1^{(i)}, e_2^{(i)})$ is contained (or not) in $KB$
%%%according to whether $u_i$ is covered by $S_j$.
%%%Since we only consider the schema with one solid edge,
%%%the complexity of finding all \textit{candidate schemas} of these $n$ entity pairs
%%%is within polynomial time, where the $j$-th candidate schema hits those corresponding entity pairs within $V_j$,
%%%with the cost function $f(S_j) = w_j$.
%%%In addition, since the function $g$ is always zero, the assignment step could be ignored (if $S_j$ is selected,
%%%then all its hitting pairs would be assigned it without bringing extra costs).
%%%Therefore, if there exists a cover $C$ satisfying the $\theta$ limit, then
%%%it's possible to select schemas covering all entity pairs with cost no more than $\theta$.

