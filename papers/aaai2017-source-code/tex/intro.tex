\section{Introduction}
\label{sec:intro}

%\KZ{\textcolor{red}{The motivation of this work includes: explaining code with human
%readable tags; duplicated code detection; code search by both
%semantic keywords and another piece of code. Use some concise but
%real world examples to illustrate these needs in software development.}}

Real-world software development involves large source code repositories. Reading
and trying to understand other code in such repositories is a difficult and
unpleasant process for many software developers, especially when the code is not
sufficiently commented. If every class or method is correctly tagged with
meaningful key phrases such as ``detect wifi'', productivity can be
tremendously improved.

%Source code repositories are the main part of software projects,
%%They are composed of thousands of related source code files which contribute to the whole project.
%%Since the software industry has been growing to a indispensable part of the society, more and more source code repositories are created. We want to create some tools through the analysis of them.
%but maintaining source code repositories takes more effort comparing with writing new files.
%Software engineers need to read others' code and try to find which part to edit.
%%Software engineers need to not only read code written by others but also try to find which part to edit.
%People are facing with such a big challenge that they are working at low efficiency.
%If we can automatically show people the topic of every method with some simple and easy understanding words in the repositories, work efficiency will improve.
%%This can help soft engineers to maintain source code repositories.
%For example, if one method is tagged with ``detect" and ``wifi", engineers can know this method is about detecting wifi and if their aim isn't related to this, they can just pass this method and continue the work without wasting time.
% %on this method when they maintain the repository .
%So, tagging methods is one motivation of our work.
%So explaining code with human readable tags is one of our motivations.% of our work in this paper.

A related scenario happens when one wants to search for a piece of code with
a specific functionality or meaning. Ordinary keyword search would not work
because expressions in programs can be quite different from natural languages.
If methods and classes are tagged with natural language keywords, then
keyword matching or even semantic fuzzy search can be achieved.
%
%We want to search one code by both semantic keywords and another piece of code. We can type into a system with some tags such as ``java, split, words", showing the
%properties of the source code repositories we want. Then the system returns people with some repositories or
%source code snippets that can split words and written by Java. On the other hand, we can also input some source code, then the system returns some codes whose function is similar to the input.
%
%

%Here comes our other motivations to design this system.
 %a system to automatically show people the topic of a source code repository.
Finally, code pieces which look quite different on the surface, due to
the use of different identifier names and different code structures,
may actually serve the same purpose.
Detecting duplicated or similar code fragments in a large repository
is a common software engineering practice that simplifies the maintenance
efforts and lowers development costs. Again, if all code pieces are sufficiently
tagged, similar pieces can be detected by comparing their tags.

To automatically create English tags for source code, one potential
solution is to represent source code by topic-word distribution using models
such as LDA~\cite{blei2003latent}. However, topic models, when applied
in source code, have a number of limitations:
%Topic models are used to process natural language and provide people the abstract topic of the documents.
%To achieve these functions we consider the topic models first, but they will produce bad results when adapted to
%source code repositories because of the following reasons:
%\KZ{\textcolor{red}{This summary is good but need a bit more explanantion, perhaps with
%examples.}}
\begin{itemize}
\item a topic model treats documents as a bag of words and ignores the
structural information such as programming language syntax and
function or method calls in the code;
\item the contribution of lexical semantics to the meaning of code
is exaggerated;
\item tags produced can only be words but not phrases.
%\item They cannot show specific theme of a method or a function.
\end{itemize}

%Besides the function in topic recommendation, people also need to check the similarity of two source code repositories,
%to see how much novelty one new project can make. However, people can change the semantic information in the
%files such as rewriting a program with the same structure and different identifiers. So we need a tool to calculate
%the similarity of two methods or files, simultaneously using the semantic information and structural information. This function is also called duplicated code detection. For example, when we merge two people's codes into one repository, we need to detect the duplicated code first, so that we can just choose one of them to merge into repository. This can help save the space of repository and make the programmer easy to maintain this repository because of less methods and files.
%
%A discussion of source code repositories is necessary.
%After long-time observation on many source code repositories and snippets from them,
%we find the following features of code, which are the sources of how people can understand the code.
%\begin{itemize}
%\item {\em Semantic information} comes from the naming of variables and methods, and the annotation or comments.
%Programmers always try to use simple words or phrases as variable names and method names, to suggest readers the
%function of them.
%%Also much information is included in the annotation and comments which are in the form of a short paragraph in natural language.
%\item {\em Structural information}, which is always related with some key words. For example, the parenthesis in C++ or Java
%is used to restrict the scope of a statement. Readers can simulate the function of code themselves with the help of
%such kind of structural information.
%\item {\em Invocation information} which means one method calls another one, namely the call graph. In source
%code repositories, many methods resort to other functions to finish a task. Such kind of invocation information
%is quite useful in code comprehension.
%\end{itemize}
%
%Topic models only abstract all individual words and merge them into a bag of words, don't utilize any structural information such as the if statement, switch statement of the source code.
%And topic models depend on the semantic information too much because they think the semantic information of words can told people the real meaning of the text. But the words in the source code are only the identifiers and these identifiers are always human-made words that don't have any semantic information at all or even is opposite to the real meaning.
%And one method only have a few words and these words are not enough to know the topic of this method in topic model.
%Since topic models work badly
%%(because topic models don't utilize the invocation information and structural information of the source code repositories. And we have implemented one topic model to mining topic of source code repository, readers can know the details and result in Section \ref{sec:topicModel})
%, %\KZ{\textcolor{red}{Do you have evidence that vanilla
%%topic models work badly? refs or experimental results?}}

Because of these reasons, in this paper, we seek to combine
the semantic and structural information from code in
a bimodal model first proposed by Allamanis et al.
\shortcite{allamanis2015bimodal}.
In that model, pairs of source code snippet and natural language description of
the code from Stackoverflow are jointly learned to make bi-directional
prediction, that is, from code to natural language and vice versa.
However, the original model targets very small code snippets that implement
a simple functionality, such as computing the maximum from a list.
We therefore extend that model and make the following contributions:
%Their model were trained to produce some tags for a short code snippet with the structural information in code and the related description in natural language.

%\KZ{\textcolor{red}{The main problems with Allamanis et al. is it's designed to handle small
%code snipet and therefore: 1) no NL semantic information in the code is
%utilized, whereas in large code repo, such NL semantic information
%exists abundantly and are useful in understanding the code
%2) it doesn't make use of invocation structures among codes
%3) performance degrades as the size of the code increases (have we provided
%a solution to this?)
%}}

%We based on the bimodal model by Allamanis et al\cite{allamanis2015bimodal} and added our new algorithm to it.
%We notice that Allamains et al's model is designed to handle small code snippet, so there are some problems with it.
%There are some problems of Allamains et al's model if we apply it to source code repositories.
%Firstly, no natural language semantic information is utilized, whereas in large code repositories, such natural language semantic information exists abundantly and is useful in understanding the code, like the comments in the repositories. And it doesn't make use of invocation structures among codes.
% while this structure is very important for source code repositories.
%To make model suit for source code repositories, we combine the natural language model and Allamanis et al's model to utilize the semantic information and tack on the invocation information into our model to show the ability to handle multiple methods.
%We noticed that in some natural language model, structural information is not included in and in Allamanis et al's
%model, similarly semantic information cannot bring too much contribution. So we combined the two kinds of
%information in one model to provide more useful information in code understanding. Also, we tacked on the
%invocation information into our model to show the ability to handle multiple methods.
\begin{itemize}
\item by adding method invocation information to the model,
we strengthen the ability to describe {\em structural information}
of source code;
\item by explicitly modeling the different identifiers as well as user comments
in the code, we enhance the {\em semantic information} in the parse tree of the
source code;
\item by experiments on ten different real-world source code repositories on
Github, our model demonstrates substantial advantage over the previous model
as well as the baseline approaches using TF-IDF and topic modeling.
% than the previous one.
%\item \KZ{Can we say anything about the execution performance?}
\end{itemize}

Next, we first briefly introduce the original bimodal model by Allamanis et al.,
and then present our approach, as well as some evaluation results. We then
discuss some related work before concluding the paper.
