\subsection{Iterated SPEA2}
\label{sec:algo_spea2}
\renewcommand{\algorithmicrequire}{ \textbf{Input:}} %Use Input in the format of Algorithm
\renewcommand{\algorithmicensure}{ \textbf{Output:}} %UseOutput in the format of Algorithm

As the definition of our problem above, we can do \emph{Action Extraction} process by a multiobjective optimization approach.
Firstly, we quantize the concept as follow:
$$
c_i =
\left[
\begin{array}{cccc}
p_{i1} & p_{i2} & \ldots & p_{in}
\end{array}
\right]
$$
where
$
p_{ij} = \left\{ \begin{array}{ll}
1 & \textrm{if $e_j$ is an entity of $c_i$}\\
0 & \textrm{if $e_j$ is not an entity of $c_i$}
\end{array} \right.
$
and $n$ is the number of entities of a verb.
Then we represent concept space as follow:
$$
\left[
\begin{array}{c}
c_1\\
c_2\\
\vdots\\
c_m
\end{array}
\right]
=
\left[
\begin{array}{cccc}
p_{11} & p_{12} & \dots & p_{1n}\\
p_{21} & p_{22} & \dots & p_{2n}\\
\vdots & \vdots & \ddots & \vdots\\
p_{m1} & p_{m2} & \dots & p_{mn}
\end{array}
\right]
$$
where $m$ is the number of concepts in the concept space of a verb. We call the left of the equation \emph{concept space} and the right of the equation \emph{concept-entity matrix}.
Finally, the result concepts set is represented as \emph{concept vector} ($cv$) :
$$
cv
=
\left[
\begin{array}{cccc}
p_{1} & p_{2} & \ldots & p_{m}
\end{array}
\right]
$$
where
$
p_{i} = \left\{ \begin{array}{ll}
1 & \textrm{if $c_i$ is a concept of the verb's object}\\
0 & \textrm{if $c_i$ is not a concept of the verb's object}
\end{array} \right.
$.

As a multiobjective optimization problem, we have three objectives:
\begin{eqnarray}
minimize\ && \sum_{i=1}^m cv[i]\\
maximize\ && \sum_{i=1}^{n}{\bigvee_{j=1}^{m}{cv[j]*c_{j}[i]}}\\
&& \sum_{\substack{i,j \in [1,m]\\i \neq j\\cv[i] = cv[j] = 1}}{\frac{\sum_{k=1}^n{c_i[k] \wedge c_j[k]}}{n}}
\end{eqnarray}
As evolutionary algorithms possess several characteristics that are desirable for this type of problem\cite{zitzler2004tutorial},
we use this search strategy to solve it.
In our paper, we produce an Iterated SPEA2 (ISPEA2) to find the resulting concepts set. ISPEA2 has two steps, the first is Iteration Main Loop and the second is SPEA2 Main Loop\cite{zitzler2001spea2}. The algorithm is as follow:
\begin{algorithm}
\caption{Iteration Main Loop}
\label{Iteration}
\begin{algorithmic}[1]
\Require
$CS$ (initial concepts set)
\Ensure $CS^*$ (result concepts set)
\State Let $CS_0 = CS$, get the concept-entity matrix as $CES_0$ and the size of $CS_0$ as $m_0$.
\State Get the new concepts set $CS_1$ by the Algorithm \ref{SPEA2}, and $CS_0$, $CES_0$ as the input.
\State Get the size of $CS_1$ as $m_1$. If $m_1 \leq 20$ and $m_0 - m_1 \leq 15$, let $CS^* = CS_1$ and the algorithm ends; else let $CS_1$ as the input and go to step 1.
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{SPEA2 Main Loop}
\label{SPEA2}
\begin{algorithmic}[1]
\Require\\
$M$ (offspring population size)\\
$N$ (archive size)\\
$T$ (maximum number of generations)\\
$CS$ (concepts set)\\
$CES$ (concept-entity matrix)
\Ensure
$A^*$ (nondominated result concept vector set)
\State \textbf{Initialization}: Generate an initial population $P_0$ by randomly initializing the concept vector as each individual in the population. And create the empty archive(external set) $A_0 = \emptyset$. Set $t = 0$.
\State \textbf{Fitness assignment}: Calculate fitness values of individuals in $P_t$ and $A_t$.
\State \textbf{Environmental selection}: Copy all nondominated individuals in $P_t$ and $A_t$ to $A_{t+1}$. If size of $A_{t+1}$ exceeds N then reduce $A_{t+1}$ by means of truncation operator, otherwise if size of $A_{t+1}$ is less than N then fill $A_{t+1}$ with dominated individuals in $P_t$ and $A_t$.
\State \textbf{Termination}: If $t \geq T$ then set $A^*$ to the set of decision vectors represented by the nondominated individuals in $A_{t+1}$. Stop.
\State \textbf{Mating selection}: Perform binary tournament selection with replacement on $A_{t+1}$ in order to fill the mating pool.
\State \textbf{Variation}: Apply recombination and mutation operators to the mating pool and set $A_{t+1}$ to the resulting population. Increment generation counter ($t = t + 1$) and go to Step 2.
\end{algorithmic}
\end{algorithm}