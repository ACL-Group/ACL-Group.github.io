\section{Introduction}
%Designing an IP core is a complex and time-consuming task. 
%A typical design cycle begins with a high-level architectural diagram.
%Then, with a lot of discipline and care, the designer translates the diagram into 
%a register transfer level (RTL) description written in a hardware description language (HDL) 
%such as Verilog or VHDL. Next, the RTL is usually subject to a verification and 
%debugging process until the description is considered logically correct. 
%Finally, a synthesis tool is used to compile the RTL into a gate netlist 
%which can be physically realized. 

Hardware description language (HDL) based IP synthesis has been the 
industry standard in recent years.
However, it has a number of problems.
First, Verilog and VHDL are so low level that they are often compared to assembly languages
in terms of programability. The absense of advanced data types and control mechanisms makes
programming in these languages tedious and error-prone. For example, to program complex
circuits, one often has to write massive amount of boilerplate code. Some
designers go as far as using Perl to generate repeated Verilog code fragments. 
Second, the simulation and verification
is the most time-consuming step in IP design cycle. For industry-strength design, 
this loop can go on for weeks and even months. This lengthy process is in part due to
the lack of static checks at compile time in most HDLs and the difficulty in formal
verification.  Third, while most HDLs offer design libraries of basic building blocks,
these are largely limited to the harware circuit level, and are often inadequate for programming
large, complex but common algorithms such as those used in cryptography and image processing.
Today, designs for these algorithms require thousands of lines of Verilog code which is
extremely expensive to produce, debug and maintain. Last, because HDLs do not offer the 
capability of high level abstraction, it is not easy to reconfigure the functionality of an
existing design. For example, for a given design of an AES algorithm, if the user prefers
to trade die space for speed, a common approach is to unroll a loop a number of times
and execute it in parallel within a clock cycle. Such unrolling cannot be achieved
in Verilog without substantial code change.

To address some of these problems, a range of new solutions have been
proposed. 
%SystemC and SystemVerilog were two of the most prominent attempts to
%simplify IP designs, albeit in opposite directions. 
SystemC gives software engineers access to hardware design by 
introducing an event-driven simulation
kernel and some ability in describing hardware in C. 
SystemVerilog, on the other hand, aids hardware designers by raising 
the abstract level of Verilog with convenient programming constructs and 
some object-oriented concepts. None of these
languages allows the specification of a design at the algorithmic level. 
%In attempt to improve productivity and to simplify design verification, 
%Accella developed 
Property Specification Language (PSL) let the designers 
add assertions in their HDL code about certain properties. 
%These assertions assist the verification tool in proving some 
%otherwise unprovable properties. 
It is nonetheless the user's responsiblity to add correct assertions
at the appropriate places. Another approach to the verification
problem is equipping the HDL with a type system and providing static checks.
A number of HDLs, most notably Bluespec \cite{Arvind03:bluespec}, 
are designed as sublanguages or 
libraries of strongly typed functional programming languages like Haskell and ML. 
While the type system in these languages eliminates some design errors at early stage,
it does not make the coding of a design any easier. To the contrary, hardware
engineers have to learn another potentially unfamilar language such as Haskell.
This is perhaps why Bluespec now uses a SystemVerilog syntax.
Probably the most relevant work to this paper is the Spiral project \cite{NordinMHP05:Spiral}
which developed systems that translate high level mathematical representations 
(in the SPL language) 
of certain DSP transforms into hardware designs. 
The work identifies a number of one-to-one correspondence between DFT formulas to 
combinatorial data paths, and hence makes the abstraction of functional components possible. 

In this paper, we propose an architecture for IP design which leverages the 
programability of SystemVerilog but extends it with a high level of mathematical abstraction. 
It allows the hardware designer to specify algorithms and constraints in their designs directly,
without concerns about the unnecessary details of hardware connections when developing larger
IPs. Our two-level compiler automatically translates a high level abstraction into 
a paramterized template, which, together with user input on the choices of the parameters, 
synthesizes to a custom RTL. This architecture generalizes the Spiral system to handle more
diverse design problems than DSP and uses a frontend familiar to most
hardware engineers. More importantly, the interactive parameter instantiation approach
conveniently exposes areas of algorithmic optimization to the designer and automatically
generates IPs that best cater to individual's requirements.
