\section{Introduction}
% 1. give a example of ambiguous relation
% 2. talk about selectional preference
% 3. talk about open ie
% Goal: Why we do this work? What's the help of pairwise selectional preference?
% Reverb has high quality

% open ie part
% 1. recent years, open ie system played an important rule
Open information extraction (or Open IE) is a task of extracting
all sorts of relations between named entities or concepts
from open-domain text corpora, without restraining itself
to specific relations or patterns.
% 2. input comes from a large scale web pages (Clueweb)
State-of-the-art Open IE systems~\cite{carlson2010toward,fader2011identifying,schmitz2012open,nakashole2012patty}
extract millions of binary relations with high precision from the web corpus.
% 3. the direct output result just stay on the lexical level tuples
Each extracted relation instance is a triple of the form
$\langle arg_1,\ rel,\ arg_2 \rangle$, where the relation
$rel$ is a lexical or syntactic pattern, and both
arguments are multi-word expressions representing the argument entities or
concepts.

% 4. it's interesting to see the semantic information hidden in these tuples.
Whereas Open IE provides concrete relation instances,
we are interested in generalizing these instances into
more abstract semantic representations.
In this paper, we focus on inferring the schemas of
binary relations.
% 5. a simple example "X is the mayor of Y", we know entity pairs, but we also want to know what kind of entities can be used here.
%For example, given the binary relation ``is the mayor of'', Open IE systems extracts lots of
%$\langle X,\ is\ the\ mayor\ of,\ Y \rangle$ tuples. The following are some tuples extracted in ReVerb:

%\begin{center}
%$\langle \text{Greg Nickels},\ is\ the\ mayor\ of,\ \text{Seattle} \rangle$
%$\langle \text{Ron Dellums},\ is\ the\ mayor\ of,\ \text{Oakland} \rangle$
%\end{center}

%The schema of a relation is represented by the semantic types at both arguments.
%We are aiming to infer these relation schemas, which contains both coarse-grained
%and fine-grained schemas:

%\begin{center}
%$\langle person,\ is\ the\ mayor\ of,\ location \rangle$
%$\langle politician,\ is\ the\ mayor\ of,\ city \rangle$
%\end{center}

%In this case, we can observe that, the argument type of X is likely to be ``person'',
%and ``location'' is likely to be the argument type of Y. More specifically, X are usually
%politicians, and Y are cities, which is a fine-grained relation schema.
% 6. an ambiguous case "X died in Y", Y can be location, or a datetime.
% For another relation tuples $\langle X,\ die\ in,\ Y \rangle$, X are usually people, but here Y can be either locations
% or dates.

For example, given the binary relation ``play in'', an Open IE system
extracts many triples of the form $\langle X,\ play\ in,\ Y \rangle$.
The following relation triples are extracted in ReVerb:

\begin{center}
$\langle \text{Goel Grey}, played\ in, \text{Cabaret} \rangle$ \\
$\langle \text{Tom Brady}, play\ in, \text{National Football League} \rangle$
\end{center}

Informally, the goal of our system is to automatically infer a set of schemas
such as $\langle t_1,~ play~ in,~ t_2 \rangle$, where $t_1$ and $t_2$ are
two semantic types drawn from a standard knowledge base
such as WordNet~\cite{miller1995wordnet},
Yago~\cite{suchanek2007WWW}, Freebase~\cite{bollacker2008freebase},
and Probase~\cite{WuLWZ12}, and each such schema can be used
to represent a set of ``play in''  relation instances.
%The schema of a binary relation, consists of semantic types at both arg1 and arg2.
%The surface form ``X play in Y'' shares multiple semantic meanings due to its ambiguity.
For the above example, two possible schemas for ``play in'' are:
\begin{center}
$\langle \textbf{film\ actor},\ play\ in,\ \textbf{film} \rangle$
$\langle \textbf{athlete},\ play\ in,\ \textbf{sports\ league} \rangle$
\end{center}

%Now considering another relation tuple $\langle X,\ play\ in,\ Y \rangle$. This is an ambiguous relation,
%where we can extract tuples having different semantic meanings:
%
%\begin{center}
%$\langle person,\ is\ the\ mayor\ of,\ location \rangle$
%$\langle politician,\ is\ the\ mayor\ of,\ city \rangle$
%\end{center}
%
%\noindent
%In this case, we aim to find all its possible relation schemas, like:
%
%\begin{center}
%$\langle athlete,\ play\ in,\ sports\ team \rangle$
%$\langle actor,\ play\ in,\ film \rangle$
%\end{center}

%One understanding is that X are athletes, and Y are sport teams.
%And there is another understanding: X are actors, and Y are films.
%As we can see, such relation is ambiguous, its surface form are shared by multiple meanings.
% 7. if we got this info, it'll be helpful in many tasks, such as searching, and qa.

The schema of a binary relation is useful information in NLP tasks,
such as context-oriented entity recognition and open domain question answering.
Suppose we are to recognize the entities in the sentence
``\textit{Granger} played in \textit{the NBA}''.
``\textit{Granger}'' is a highly ambiguous term, while ``\textit{the NBA}''
is probably a sports league. Then with the the above relation schemas for
``play in'', the entity recognizer knows that ``\textit{Granger}''
is more likely to be an athlete, which results in the correct linking to
``Danny Granger'', who is an NBA player, even though the Open IE
has never extracted such fact before.
%Suppose we've known the argument at one side of a relation, type pairs will help us inferring what kind of entities are more likely
%to occur at the other side.

%Structured knowledge base (KB) is a taxonomy containing real world entities, types, relations between entities
%and ``IsA'' relation between entities and types. Structured KBs such as WordNet \cite{miller1995wordnet},
%Yago \cite{suchanek2007WWW} and Freebase \cite{bollacker2008freebase} are widely used in information extraction
%and semantic learning tasks. In order to make relation schemas understood by human, we leverage types
%in the KB as the output of relation schemas.

%For the purpose of relation schema inference, any ontology or taxonomy of
%entities and concepts (or types) connected by isA relation can be
%used. Examples include WordNet~\cite{miller1995wordnet},
%Yago~\cite{suchanek2007WWW}, Probase~\cite{WuLWZ12}
%and Freebase~\cite{bollacker2008freebase}.
%In this paper, we choose to use Freebase as our target ontology
%Because Freebase~\cite{bollacker2008freebase} is a widely used
%community supported ontology for entity linking and question answering,
%this paper seeks to infer schemas using Freebase types.
%
%Freebase contains more than 40 million entities, and has
%a type hierarchical structure with more than 1,700 real types
%\footnote{Freebase types are identified by type id, for example, $sports.pro\_athlete$ stands for ``professional athlete''.}.
%Each entity belongs to at least one type.
%When compared with other knowledge bases, Freebase has a much greater focus on named entities than {\tt WordNet}.
%Besides, the type hierarchy of {\tt Yago} is too fine-grained, which is not suitable for schema inferring.
%Considering aspects mentioned above, we adapt Freebase as our knowledge base in our work.
%

%The most relevant technique to achieve our goal is
%\textit{selectional preference} (SP)~\cite{}, which computes the most
%appropriate type for a particular argument (e.g., subject or object) of a
%predicate. There are different approaches in computing SP. Class-based
%approach~\cite{resnik1996selectional} seeks to map each argument of a relation
%to entities in a taxonomy such as WordNet, and abstract the arguments into
%human readable types from the taxonomy. Other non-class based approaches
%\cite{erk2007simple,ritter2010latent} cannot produce human readable type names
%because they either rely on distributional properties or produce types as
%latent variables. As a result, non-class based methods are not suitable for
%inferring schemas which must be readable by humans. The approach proposed
%in this paper is a variant of class-based SP, whose primary difference is
%that the most preferred types for both arguments of a binary relation
%are computed simultaneously, rather than on each individual arguments.

One relevant technique to achieve our goal is \textit{selectional preference}
(SP)~\cite{resnik1996selectional,erk2007simple,ritter2010latent},
which computes the most appropriate types for a specific argument of
a predicate. SP is based on the idea of mutual information~\cite{erk2007simple},
which tends to select types which are {\em unique} to the relation.
In other words, common types which can be used for many different relations
are less preferred.
% add disadvantage of SP
However, in Open IE, many relations are related or even similar, e.g.,
{\em play in}, {\em take part in} and {\em be involved in}. There's no reason
for these relations not to share schemas. Therefore in this paper, our problem
is, given a relation and its instances, identify the smallest types that
can cover as many instances as possible.
%Intuitively, when we human infer the schema for a relation,
%we prefer to choose those schemas which are suitable under most circumstances.
%Moreover, it would be better if a schema is more specific.
%Based on this idea, we propose an approach to infer best type
%schemas for binary relation.
Our approach first attempts to link the arguments in the relation instances to
a set of possible entities in a knowledge base,
hence generate a set of $ \langle e_1, e_2 \rangle$ entity pairs.
Then we select a pair of types $ \langle t_1, t_2 \rangle$ that covers maximum
number of entity pairs. We resolve ties by selecting the smaller (more
specific) types according to a type taxonomy inferred from knowledge base.


%
%Learned by previous examples, the key challenge for relation type inferring
%is that, type distributions of both arguments
%should be modeled simultaneously, and the preference of different schemas should be comparable with each other.
%\KQ{If type distributions for $arg1$ and $arg2$ are modeled separately, we lose the information in combining.}
%As the previous example ``play in'' shows, if we only know preferred types for X and Y independently,
%it's hard to tell what kind of Y is likely to be when X is an actor.
%
%% sp part (intuition: get the human readable types)
%% 1. what is sp ?
%Selectional Preference (SP) is the technique to get certain types that is more likely than other
%types to be the argument of one relation.
%% 2. with such constraint, we can let the computer know whether a relation argument is suitable or not.
%%%%With this kind of type constraint, we can compare the possibility of types
%% 3. basic sp: resnik 1996 on wordnet
%One branch of SP is knowledge based, types are mapped to structured knowledge bases, such as WordNet \cite{miller1995wordnet}, Yago \cite{suchanek2007WWW} and Freebase \cite{bollacker2008freebase}. The earliest work in SP is proposed by Resnik \shortcite{resnik1996selectional}, which is based on WordNet.
%% 4. recently, sp with topic models
%The other branch is statistical based, argument types are generated by topic models like Latent Dirichlet
%Allocation \cite{blei2003latent}.
%% 5. leverage external taxonomy, for example, Freebase provide its type taxonomy, which is well-defined by ..., containing 1000+ useful types. (Comparing to Yago and DBPedia), and human readable.
%One main advantage of knowledge based SP is that, given a well-defined type taxonomy, the argument types of can be easily understood by human.
%Thus, our work is built on knowledge based SP.



%% 6. we can use fb ty%pes to represent result. (list the previous examples)
%Using Freebase type taxonomy as the external knowledge, for the previous two relations,
%the preferred relation schemas can be represented as:
%
%\begin{center}
%$\langle politician,\ is\ the\ mayor\ of,\ citytown \rangle$
%$\langle athlete,\ play\ in,\ sports\_team \rangle$
%$\langle film\_actor,\ play\ in,\ film \rangle$
%\end{center}
%
%\noindent
%Where argument types are corresponding to Freebase types.
%showing the different interpretations of relations.


% our contribution
% 1. our goal is to find different selectional preference for one relation. (located to human readable types)
%In this paper, our goal is to generate argument types for binary relations, generating all possible
%relation schemas, which are human readable.
% 2. build rvsp, a xxxx based on xxxx.
This paper makes the following contributions: i) we defined the schema
inference problem for binary relations from Open IE;
ii) we developed a prototype system based on Freebase and
entity linking~\cite{lin2012entity,ratinov2011local,hoffart2011robust,rao2013entity,CaiZZW13}, which simultaneously models the type distributions
of two arguments for each binary relation;
iii) our experiment on ReVerb triples showed that the top inferred schemas
receive decent mean reciprocal rank (MRR) of 0.337,
with respect to the human labeled ground truth.
% 3. first entity linking, then pairwise selectional pref.
% 4. use syntactic info to merge similar relations to a big one.
% 5.
% 6. currently, rvsp got xxx relations, and xxx sel. pref.


