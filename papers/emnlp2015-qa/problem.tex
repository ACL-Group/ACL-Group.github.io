\section{Problem Definition}
\label{sec:problem}

%\KZ{We need to give a formal definition of the problem: the mathematical notion of
%open IE triples, structure of the taxonomy, and exactly what we are seeking as output. We can
%borrow notions from selectional preference paper and also papers on database schema inference.
%The informal description in the intro before was too vague and I removed it with only the example
%left.}

% What is KB (entity, relation, edge) (definition of a taxonomy)

% What is schema:
%   goal is to define a scoring function
%   calculate the SP (a kind a correlation) between relation and schema

%In this section, we give the formal definition of relation schema inferring.
%We first introduce some mathematical notations.

%----------------- Review ----------------
%the task definition in Section 2 seems more restrictive than what is really addressed in the paper. The task talks about outputting a single type pair for a given relation, but actually a ranking of type pairs is what is output and evaluated, and multiple correct answers are possible (this is the right task to evaluate -- it's only the definition in Sec 2 that is too restrictive, not the experiments). It's also not really the solution the paper uses, because the paper's method has a softer method that balances specificity and coverage somewhat (equation 6).
%----------------- Review ----------------

A knowledge base $K$ is a 5-tuple $\langle E, Alist, T, $ $P, IsA \rangle$,
where:
\begin{itemize}
    \itemsep=-0.2cm
    \item[-] $E$ is a finite set of entities $e \in E$,
    \item[-] $Alist(e) = \{n_1, n_2, ...\}$ is a function which returns
    a set of names (or aliases) of an entity,
    \item[-] $T$ is a finite set of types $t \in T$,
    \item[-] $P$ is a finite set of relation instances $p(e_1, e_2)$, where
    $p$ is a predicate in $K$.
    \item[-] $IsA$ is a finite set entity-type pairs $(e, t)$, 
    representing the isA relation between entities and types.
    An entity belongs to at least one type.
\end{itemize}

%A knowledge base \[K = (E,\ T,\ P,\ IsA, Alist, Tlist)\]
%is composed of a set of entities
%$E$, a set of types $T$, a set of predicates $P$ between different entities,
%$IsA$ relations between entities and types and two functions $Alist$ and
%$Tlist$. \KZ{What exactly is the IsA relation? Is it only explicit between
%type and entity and not explicit between types? Later you said it's
%difficult to generate type subsumption relation...}
%\KZ{Is Tlist really necessary? Isn't it sufficient to have IsA between
%$e$ and $t$?}
%Each $e \in E$ has a set of names (or aliases),
%defined as $Alist(e)=\{n_1,~ n_2,~ ...\}$.
%Due to ambiguity, different entities may share a same name.
%All types linked to entity $e$ by $IsA$ relations are defined as
%$Tlist(e)=\{t_1,~ t_2,~ ...\}$. We say a name $n$ is {\em covered} by
%a type $t$ if there exist some $e$, such that $n \in Alist(e)$, and
%$t \in Tlist(e)$. In addition, we say $t_1 \subseteq t_2$ if
%every entity $e$ in $t_1$ is also in $t_2$.

%$t_1~ \rm{isa}~ t_2$ according to $IsA$.

%For example, the entity $NewYorkCity$ has several names, such as ``New York City'', ``NYC'' and ``Empire City'',
%and it belongs to multiple types, like coarse-grained type $location$ and fine-grained type $city$.

%In $K$, two entities $e_i$ and $e_j$ are $k$-hops reachable,
%if there exists a sequence of entities $\{e_i,~ e_1,~ e_2,~ ...,~ e_{k-1},~ e_j\}$,
%where every pair of neighboring entities are connected by a
%predicate $p \in P$.

% Open IE
An Open IE triple set $S$ contains all relation instances extracted
by the IE system, of the form
$\langle a_1,\ rel,\ a_2 \rangle$, where $a_1$ and $a_2$ are
the arguments of extracted relation pattern $rel$. The set of argument pairs
sharing the same relation pattern $rel$ is denoted by $S_{rel}$.

The problem is, for each $S_{rel}$, return a set of type pairs (or schemas)
from $T$, $\langle t_1, t_2 \rangle$, ordered by the number of argument pairs
covered in $S_{rel}$.  %any other type combinations from $T$.
If two schemas cover the same number of argument pairs from $S_{rel}$,
the schema covering smallest number of entities wins.


% SP(we don't use "selectional preference", but use some other words like "correlated with each other ?" Refer to other papers)
%For one relation pattern $rel$, all its support tuples in $S$ form a group,
%defined as $group(S,\ rel)$.
% Put relation group here

%Given triple set $S$ and taxonomy $TX$ as input,
%the task of relation schema inferring is to output all scored relation schemas $\langle t_1,\ rel,\ t_2 \rangle$ for different relation patterns,
%where both $t_1$ and $t_2$ are types in $T$, and the type pair $\langle t_1,\ t_2 \rangle$ is plausible and highly correlated to $rel$.
%Formally, relation schema inferring consist of three subtasks.
%The first one is to identify all different relation patterns $rel$ in $S$.
%Then for each $group(S,\ rel)$, the system outputs a list of type pairs $\langle t_1,\ t_2 \rangle$.
%And finally, for each $rel$, the system defines a scoring function $score(rel,\ \langle t_1, t_2 \rangle)$,
%computing the preference score for every schema and return the ranked list of schemas.

%Now we formally define the task of relation schema inference.
%Given triple set $S$ and taxonomy $TX$ as input, the task consists of three subtasks.
%
%Firstly, we identify all the semantically different relation patterns $rel$ in $S$.
%
%Secondly, for each tuple $\langle arg_1,\ rel,\ arg_2 \rangle$ in $group(S,\ rel)$,
%we link both arguments into entities that they represent in the tuple, resulting in linked tuples:
%$ltup = \langle e_1,\ rel,\ e_2 \rangle$, where $e_1 \in T$, $e_2 \in T$.
%In addition, $e_1$ and $e_2$ is $k$-hops reachable in $TX$, where $k$ is a parameter.
%
%Thirdly, given all linked tuples of $rel$ in $group(S,~ rel)$,
%we find all relation schemas $\langle t_1,~ rel,~ t_2 \rangle$, where $t_1 \in T$, $t_2 \in T$, such that:
%\begin{itemize}
%\item[*] At least $\delta$ link tuples $\langle e_1,\ rel,\ e_2 \rangle$ support the schema,
%that is, $t_1 \in Tlist(e_1)$, and $t_2 \in Tlist(e_2)$.
%\item[*] The schema is informative and highly associated with $rel$.
%We choose schemas which maximize the corresponding coverage of tuples in $group(S,\ rel)$, and provide more specific concepts in the meantime.
%%We define a scoring function $f$ to compute the association score between relation and schema,
%%and choose schemas where $f(rel,~ \langle t_1,~ t_2 \rangle) \geq \epsilon$.
%\end{itemize}
%


%\KZ{This section is still not formal and mathematical enough. Kangqi, you
%need to consult other papers on how to do this appropriately.}
% type in FB

