\section{Algorithm}
\label{sec:algo}
We allocate each node a Possible Location List(PLL) to record each node's possible locations after the last contact, and we initialize the node i's PPL with the node's initial location $L_{i0}$. When we get a contact of two nodes, through the Breath First Searching from the initial locations, we get new PPLs of the two nodes. Then we merge two PPL through verifying which couple of two nodes' possible locations satisfy the contact condition, so that we exclude the nodes' impossible locations from the PPL. With the PPL contact updating process, we get several possible traces as the possible solutions to our problem. We record these solutions in each node's trace list $Trace_i$, we give out our algorithm as Algorithm.\ref{ago:baseline}
\begin{algorithm}[htbp]
\caption{Approach}
\begin{algorithmic}[1]\label{ago:baseline}
\STATE{\textbf{Input}:$M$, $N$, $\{v_i\}$, $\{l_i(0)\}$, $H$ }\\
\textbf{Initialization}:
\FOR{$i\leftarrow 1$ to $|N|$}
\STATE{$PLL_i \leftarrow l_i(0)$, $t_i=0$, $Trace_i=\emptyset$}
\ENDFOR \\
\textbf{Inference}:
\FOR {$k \leftarrow 1$ to $|H|$}
\STATE {get $H_k$=$(i, j, t)$}
\STATE {$L_1=PPL_i, L_2=PPL_j$, $s_i=v_i(t-t_i), s_j=v_j(t-t_j)$}
\STATE {empty $PPL_i, PPL_j$}
    \IF {$s_i\not=0$ and $L_1\not=\emptyset$}
         \STATE {search for all possible location \{$l_i(t)$\} based on $s_i$}
         \STATE {$PPL_i \leftarrow \{l_i(t)\}$}
    \ENDIF
    \IF {$s_j\not=0$ and $L_2\not=\emptyset$}
         \STATE {search for all possible location \{$l_j(t)$\} based on $s_j$}
         \STATE {$PPL_j \leftarrow \{l_j(t)\}$}
    \ENDIF
\STATE {Combination($PPL_i$, $PPL_j$)}
\STATE {$t_i=t, t_j=t$, $Trace_i \leftarrow (PPL_i, t_i)$, $Trace_j \leftarrow (PPL_j, t_j)$}
\ENDFOR \\
\textbf{Selection and Output}:
\FOR{$i\leftarrow 1$ to $|N|$}
\STATE{choose the trace $Trace_{max}$ of maximal time $t_i$ from $Trace_i$}
\STATE{Output $Trace_{max}$}
\ENDFOR
\end{algorithmic}
\end{algorithm}
