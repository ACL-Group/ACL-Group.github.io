\section{Our Approach}
\label{sec:algo}
We first make some preliminary definitions.
An HTML {\em Document Object Model} (DOM) is a tree structure whose nodes are 
HTML elements identifiable by HTML tags and associated attributes. 
A {\em tag path} is a path from the root to an arbitrary node in the DOM tree. 
A top-$k$ list item, or {\em list item} in short, is a segment of HTML page which
represents a unique item in the top-$k$ list of a top-$k$ page. 
A list item can contain multiple {\em item components} such as a title (which is
often the name of an entity), some descriptive text or an image.

Our basic algorithm runs in four steps. First, we compute the tag path
for every node in the DOM tree of the input page. Second, we group nodes
with an identical tag path into one {\em equivalence class}, and we
select those equivalence classes which have exactly $k$ members as our
candidate classes. In effect, an equivalence class represents a list of 
item components. Third, for each of these candidate classes, we
employ an {\em GrowUp} operation to merge some of the equivalence classes
together, which essentially form a number of candidate lists. Now
the item components that belong to the same list item are grouped together.
Finally, we rank the candidate list by their importance to the page, and
return the top ranking list as the result. If there doesn't exist any
candidate list, then this input page is not a top-$k$ page.

The basic algorithm solves most but not all top-$k$ list extraction problems.
To improve the result quality and the performance, we further introduce
four optimization heuristics.

\begin{enumerate}
\item {\bf Visual Area.}
In the basic algorithm, the relative importance of a candidate list to the
whole page is calculated as number of text characters in the list against
the total number of text characters. This doesn't work when the list
contains large non-text areas such as white space or images, or the list
uses large fonts. As an enhancement, we try to estimate the total 
{\em visual area} of the candidate list versus the total area of the page.
This can done by the calculating the combination of image sizes, font sizes 
and potential white spaces.

\item {\bf Interleaving Lists.} For aesthetic reasons, a top-$l$ list may 
have an ``interleaving pattern'', where list items have alternate visual styles
such as background colors or fonts. In the basic algorithm, 
this kind of list may be treated as two lists of size $k/2$ and removed
mistakingly. We include a special heuristic to detect such interleaving
patterns and reconstruct the whole list from two smaller candidate lists. 

\item {\bf $k+1$ Problem.}
Some top-$k$ pages have a top-$k$ list with an additional header or footer
that looks almost exactly the same and has the same tag path
as the real list items. 
The basic algorithm cannot distinguish between the real items and this
``fake'' item. There is a similar $k-1$ problem where the first or the last
item of the real top-$k$ list has a slightly different style and is excluded
from the equivalence class. We pay special attention to equivalence classes
of size $k+1$ and $k-1$ and try to identify these boundary cases by
comparing the subtree of the items or analyzing the text content.

\item {\bf Item Title Extraction.} From our observation of many top-$k$ pages from 
different domain, we generalized a number of rules for identifying the
title entities in a top-$k$ list. For example, titles are often placed before
other item components, and often occupy a single line in the rendered
display with stylized fonts.
\end{enumerate}


