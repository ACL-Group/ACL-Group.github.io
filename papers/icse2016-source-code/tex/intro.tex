\section{Introduction}
\label{sec:intro}

%\KZ{\textcolor{red}{The motivation of this work includes: explaining code with human
%readable tags; duplicated code detection; code search by both
%semantic keywords and another piece of code. Use some concise but
%real world examples to illustrate these needs in software development.}}

Source code repositories are the main part of software projects.
They are composed of thousands of related source code files which contribute to the whole project.
Since the software industry has been growing to a indispensable part of the society,
more and more source code repositories are created. We want to create some tools through the analysis
of them.



However, maintaining source code repositories take more effort comparing with writing new files.
Software engineers need to not only read code written by others but also try to find which part to edit.
People are facing with such a big challenge that they are working at low efficiency.
If we can automatically show people the topic of every methods and files with some simple and easy understanding words in the repositories, soft engineers will be easier to find which part to edit. This can help soft engineers to maintain source code repositories. For example, if one method is tagged with "detect" and "wifi", programmers can know this method is about detecting wifi and if their aim isn't related to this, they can just pass this method and continue the work without wasting time on this method when they maintain the repository .
So explaining code with human readable tags is one of our motivations of our work in this paper.


Here comes our other motivations to design a system to automatically show people the topic of a source code repository.
Besides the function in topic recommendation, people also need to check the similarity of two source code repositories,
to see how much novelty one new projects can make. However, people can change the semantic information in the
files such as rewriting a program with the same structure and different identifiers. So we need a tool to calculate
the similarity of two methods or files, simultaneously using the semantic information and structural information. This function is also called duplicated code detection. For example, when we merge two people's codes into one repository, we need to detect the duplicated code first, so that we can just choose one of them to merge into repository. This can help save the space of repository and make the programmer easy to maintain this repository because of less methods and files.

Another function we want to realize is "code searching". We want to search one code by both semantic keywords and another piece of code. We can type into a system with some tags such as "java, split, words", showing the
properties of the source code repositories we wants. Then the system returns people with some repositories or
source code snippets that can split words and written by Java. On the other hand, we can also input some source code, then the system returns some codes whose function is similar to the input.

A discussion of source code repositories is necessary.
After long-time observation on many source code repositories and snippets from them,
we found the following features of code, which are the sources of how people can understand the code.
\begin{itemize}
\item {\em Semantic information} comes from the naming of variables and methods, and the annotation or comments.
Programmers always try to use simple words or phrases as variable and method names, to suggest readers the
function of them. Also much information is included in the annotation and comments which are in the form
of a short paragraph in natural language.
\item {\em Structural information}, which is always related with some key words. For example, the parenthesis in C++ or Java
is used to restrict the scope of a statement. Readers can simulate the function of code themselves with the help of
such kind of structural information.
\item {\em Invocation information} which means one method calls another one, namely the call graph. In source
code repositories, many methods resort to other functions to finish a task. Such kind of invocation information
is quite useful in code comprehension.
\end{itemize}

Topic models are used to process natural language and provide people the abstract topic of the documents.
Though topic models can solve similar problems, they will produce bad results when adapted to
source code repositories because of the following reasons:
%\KZ{\textcolor{red}{This summary is good but need a bit more explanantion, perhaps with
%examples.}}
\begin{itemize}
\item Topic models neglect the structural information provided by code;
\item The contribution of semantic information to the meaning of code is exaggerated;
\item They cannot show specific theme of a method or a function.
\end{itemize}
Topic models only abstract all individual words and merge them into a bag of words, don't utilize any structural information such as the if statement, switch statement of the source code.
And topic models depend on the semantic information too much because they think the semantic information of words can told people the real meaning of the text. But the words in the source code are only the identifiers and these identifiers are always human-made words that don't have any semantic information at all. Even identifiers's semantic information is opposite to the real meaning.
Topic models tell people the theme of texts based on the words in these texts, but one method only have a few words and these words are not enough to know the topic of this method.

Since topic models work badly(because topic models don't utilize the invocation information and structural information of the source code repositories. And we have implemented one topic model to mining topic of source code repository, readers can know the details and result in Section \ref{sec:topicModel}), %\KZ{\textcolor{red}{Do you have evidence that vanilla
%topic models work badly? refs or experimental results?}}
we try to combine the semantic and structural information together
in our model. Allamanis et al\cite{allamanis2015bimodal} had developed a model to combine
source code snippets and natural language and also form a bimodal model which can map both from code to natural
language and from natural language to code. Their model were trained to produce some tags for a short
code snippet with the information from structural information in code and the related description in natural
language.

%\KZ{\textcolor{red}{The main problems with Allamanis et al. is it's designed to handle small
%code snipet and therefore: 1) no NL semantic information in the code is
%utilized, whereas in large code repo, such NL semantic information
%exists abundantly and are useful in understanding the code
%2) it doesn't make use of invocation structures among codes
%3) performance degrades as the size of the code increases (have we provided
%a solution to this?)
%}}

We based on the bimodal model by Allamanis et al\cite{allamanis2015bimodal} and added our new algorithm to it.
We noticed that Allamains et al's model is designed to handle small code snippet. And because of this, there are some problems with Allamains et al's model. Firstly, there is no natural language semantic information in the code is utilized, whereas in large code repositories, such natural language semantic information exists abundantly and are useful in understanding the code like the comments in the repositories. And it also doesn't make use of invocation structures among codes but this structure is very important in the source code repositories.
So we combined the natural language model and Allamanis et al's model to utilize the semantic information and tacked on the invocation information into our model to show the ability to handle multiple methods.
%We noticed that in some natural language model, structural information is not included in and in Allamanis et al's
%model, similarly semantic information cannot bring too much contribution. So we combined the two kinds of
%information in one model to provide more useful information in code understanding. Also, we tacked on the
%invocation information into our model to show the ability to handle multiple methods.

In this paper, we make the following main contributions:
\begin{itemize}
\item Strengthening the ability of the previous model to describe structural information of source code, adding invocation information.
\item Adding comments information into parse tree and processing identifiers to describe more semantic information of source code.
\item Transferring the model from short code snippets to large code repositories, which can show more powerful
function in software industry.
\item Showing our results on ten different source code repositories and comparing the results with the
previous model. %\KZ{\textcolor{red}{Five is probably not enough.}}
Results show that our model works better than the previous one.
\item \KZ{Can we say anything about the execution performance?}
\end{itemize}
