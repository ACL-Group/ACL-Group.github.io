In order to concretely illustrate the use of tree partitioning, 
we reuse the FR example described in Section \ref{sec:examples}. 
Suppose, in Figure \ref{fig:flight}, a traveler $T_1$ wants to 
buy either $a\to b$ or $a\to c\to b$, while another traveler $T_2$
wants to buy either $d\to e$ or $d\to b\to e$. 
Then $R_1=\{ab,ac,cb\}$ are resources that $T_1$ is interested in, 
and $R_2\{de,db,be\}$ are resources that $T_2$ is interested in. 
For $T_1$ and $T_2$ there is no need to ``multiply'' their choices 
together. Also suppose the agents with interleaving interests in $R_1$ 
and $R_2$ create a tree of $p$ and $q$ leaf worlds respectively. 
By using tree partitioning, we only get $p+q$ instead of $pq$ worlds. 

Intuitively, tickets between different cities should be separated in this way. 
However, in Listing \ref{lst:tsell}, the ticket seller's agent touches 
every ticket, so it's considered by the system to be interested in 
both $ab\in R_1$ and $de\in R_2$. In this case, two trees containing 
$T_1$ and $T_2$ will be merged together. 
In order to benefit from tree partitioning, the ticket seller 
should be moved out of the system and creates a short-lived actor 
for each of the tickets (see Listing \ref{lst:tsell-ex}).
There's no need to modify the ticket buyer's agent program. 

\begin{figure}[tb]
\begin{lstlisting}[label=lst:tsell-ex,caption=Ticket Seller's Program Making Use of Tree Partitioning. {\tt spawn\_process()} creates a short-lived actor for interacting with the system of virtual worlds. {\tt \{...\}} denotes a separate program code instead of evaluation.]
Ts = ...  // tickets as in Listing |\ref{lst:tsell}|
loop
  T = Ts[rand(6)]
  if rand(1) = 0
    spawn_process{|$\Out$|(ticket, T[0].T[1], T[2])
                  |$\exit$|}
  else
    spawn_process{|$\Out$|(ticket, T[1].T[0], T[2])
                  |$\exit$|}
\end{lstlisting}
\end{figure}
