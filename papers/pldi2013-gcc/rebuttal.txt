Review#1:

1.We propose a new programming model where speculation is intrinsic
  rather than a new language.  Features in reflection languages may help
  the implementation but we focus on the new paradigm.  Erlang is chosen
  for prototyping given its efficiency and scalability.

2.STM transaction effects become visible to another thread all at once,
  so one thread must finish execution on its own and not block, which
  isn't the case of inter-agent interactions.  Choices in our framework
  can block indefinitely/forever, which is not handled by "retry".
  Moreover agents can concurrently update the store within an alternative,
  hence, the isolation is different.

3.The work is not wasted.  Without such exploration we cannot know
  which outcome is useful.  The correct choice can depend on future
  inter-agent interactions.

4.The data model is independent from the framework.  Linda-style
  tuple-spaces fit our examples well but other stores are possible
  (see Sec2.1)

5.(commit) See response#2 for review#2.

6.Conceptually the stores are in leaf worlds.  In our implementation it's
  possible to have sharing and other optimizations.  Our prototype has
  some but further optimizations are beyond the scope of this submission.



Review#2:

1.We have two contributions:
  (a) Our semantics deals with exit (necessary for an agent to return to 
      external computation), includes a more practical, easier-to-implement 
      commit, and allows greater expressibility with arbitrary data models 
      and local computation languages.
  (b) We provide a real implementation in a real programming language with
      essential optimizations.

2.Commit is analogous to "cut" in Prolog.  Using commit is not
  necessary, and its use involves an inevitable trade-off between speed
  and solution quality.  We allow commit in arbitrary positions so
  programmers can flexibly leverage this trade-off.

3.The number of loops in the evaluation for FR is 6*N where N is the
  number of agents.  So it's 60,...,240 for N=10,...,40.

4."anomalies" was a wrong choice of word here.  What we meant is that
  in ST the number of worlds doesn't necessarily increase when there're
  more agents.  We also found some unexpected behavior in Erlang where
  thread overheads have periodic spikes at certain numbers of threads.

5.A benchmark is repeated M times for any fixed number of agents N.
  For FR, M=3; for ST and DP, M=10.  The exit results include all M runs
  for all N's.  For example, in DP, N=10,20,30,40,50, so the total number
  of agents in Fig.8(l) is 1500=(10+...+50)*M=150*10.

6.In listing 7, P2 and Q2 are assigned by pattern matching:
                      in(ack,Me,_,_) = (_,_,P2,Q2)
  Our examples follow the syntax in Fig.4 but portions of the code include
  local computation whose syntax is arbitrary in our framework and 
  Erlang-style syntax is employed.



Review#3:

1.The reviewer may have misunderstood the meaning of "speculation".
  Speculation here is not for performance in computer architectures (e.g.
  Itanium processor), rather it's for intrinsic expressibility to enable
  different possible agent interactions.

2.We are not aware of existing systems with the expressive power here, thus 
  the flight and stock trading examples are not taken from the literature 
  but rather represent canonical new speculation-enabled applications.
