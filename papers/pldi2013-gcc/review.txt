PLDI 2013 - Author Response form

First
reviewer's
review	
          >>> Summary of the submission <<<

This paper introduces a new concurrency control mechanism that allows the
construction of parallel "virtual" worlds, essentially different
environments and stores within concurrent copies of agents may execute.
Execution in these different worlds are isolated, and represent different
speculative behaviors. Various primitives to prune worlds, exit from a
speculative context, etc. are provided. A prototype implementation in
Erlang is given.

          >>> Evaluation <<<

The idea of virtual worlds is appealing in the abstract, and perhaps in
logic-based languages specifically, where backtracking and committed choice
semantics is already well-understood, even useful. However, the paper
suffers from some weaknesses explained below that make it a bit premature
for publication.

1. There has been much work in the functional language community, for
example, on first-class stores, environments, and continuations. Reflective
programming languages such as Brown, Blond, 3-Lisp, Rascal, etc. allow
complete control over program state, effectively providing the necessary
building blocks to build virtual worlds. There is no discussion in the
paper on how the proposed speculation mechanism relates to these earlier
designs.

2. Beyond reflection, software transactional memory and related optimistic
concurrency control techniques provide a measure of speculation without the
unconstrained generation of state and agent copies supported here; STM
Haskell, for example, allows judicious exploration of a search space via its
retry mechanism. To justify the merits of your approach, it is essential to
compare the performance of your technique with more well-understood
optimistic concurrency mechanisms.

3. The mechanism would appear to allow uncontrolled numbers of virtual
worlds to be spawned easily; the syntax and underlying semantics seem to
encourage such construction. But, I don't see how this can possibly be
viewed as an efficient device that programmers should be encouraged to use:
after all, if the common case is that there's only one useful outcome, the
work computed by all virtual worlds not chosen is clearly wasted. This
wasted work is proportional to the number of agents in the system.

4. There's little motivation provided for using Linda. Is there anything
particular about Linda that makes the development easier or more
interesting? If you are going to use Linda, why not have multiple
first-class tuple-spaces to represent the data store for separate worlds?

5. The discussion of how commit should be used would be stronger if there
were design patterns based on experience using the abstraction to hide
away some of its problematic uses. In general, the examples given in the
paper were too limited for me to fully understand how I might use commit
in practice.

6. The system implementation section does not discuss state replication,
optimizations for minimization, or sharing opportunities. What are the
conditions under which worlds can share state? The experiments and
implementation discussion does not refer to this issue at all.


-----


Second
reviewer's
review	
          >>> Summary of the submission <<<

The submission presents a programmable concurrency control framework
that allows the development of distributed agents that affect one
another through updates on a set of shared resources. As there is no
centralized coordination of the agents the results of the execution
are nondeterministic, and the behavior of each agent can employ
speculation in an attempt to reach its goal. The developer enables
speculation in an agent by specifying exclusive choices that the
runtime system developed by the submission executes in combinatorial
and mutually exclusive environments called worlds. The number of
worlds grows exponentially with the number of agents speculating, and
is limited by optimizations developed in the submission including an
exit mechanism to allow agents to exit the virtual worlds even as
other agents are still speculating and deferring creation of virtual
worlds until two agents compete for the same resource. The evaluation
on three benchmarks developed by the authors shows that the number of
concurrent worlds is effectively constrained by the optimizations
employed and as a result the execution time and memory usage of the
system tend to grow linearly with the number of agents in the system.

          >>> Evaluation <<<

The submission is an extension of previous work by Jaffar. The
authors claim that the contribution of this submission is the
development of a control framework that allows concurrent agents to
speculate through the specification and execution of exclusive choices
and exit from the virtual worlds created by speculation while other
agents are still speculating. After reviewing reference [18] by
Jaffar it seems that the capability to execute speculatively was
present in previous work, while the exit capability is a novel
contribution.

The submission states its contributions as the formalization of a
concurrency framework and the implementation of the framework in a
prototype system that demonstrates effective pruning of virtual
worlds. The formalization provided in the submission is similar to
that provided in [18] by Jaffar and isn't more extensive or
thorough. What the submission appears to have as a real contribution
is the implementation of the prototype system used in the evaluation.

The tree partitioning technique employed in the system implementation
is an interesting idea. The authors note that the trees for agents do
not have to be combined when the agents are not competing for
resources. Avoiding unnecessary combination of the trees is one of
several optimizations the authors present that helps keep the number
of virtual worlds created in the experimental evaluation in a linear
relation with the number of agents instead of an exponential
relationship.

In section 2.5 the authors note that the user should employ the commit
mechanism with care as its overuse may result in over pruning the
virtual worlds and the loss of valuable solutions. This seems to be a
difficult problem for the user to address. How can the proposed
system be employed to assist the user in this regard?

The presentation of the submission needs to be improved. First, the
syntax used in the examples of subsection 2.3 is not the syntax for
the framework developed by the authors in the submission. The
examples need to be rewritten to demonstrate the utility of the
proposed language.

The presentation of the evaluation section can be improved in several
areas. The specification of the examples needs to be more precise.
The submission states that in the Flight Reservation system the seller
agent "loops for several times". The specification of the bounds
placed on the agents needs to be precise. The anomalies mentioned in
Section 4 appear in all cases (minimum, average, and maximum). The
authors mention that they should be due to the special combination of
trading strategies. If the choice in strategy is random, how is the
anomaly present in all cases?

Finally, in the evaluation section the number of agents shown in
column (d) for each benchmark is a much larger number of agents than
in the previous columns. The evaluation section needs to clearly
explain how many agents were used in each experiment and how the total
number of agents is computed.

The key concern about the submission is its novelty. A clearer statement of
the submission's contribution to the state of the art is required.
The formalization of the framework needs to be more rigorous.
Finally, the presentation of the experimental evaluation should be
improved by specifying the iteration bounds placed on any agents, the
number of agents used in each experiment, and how the number of agents
benefiting from the exit mechanism is computed.

Detailed presentation notes:

1. In listing 7 it appears that the assignments of P2 and Q2 have been missed.

2. The proof sketch for the general dining philosophers lack of
deadlock in speculative nondeterminism is written in a way that leads
the reader to believe that the first step of the proof is constructing
a deadlock free ordering, which is what the benchmark is supposed to
find.


-----


Third
reviewer's
review	
          >>> Summary of the submission <<<

This paper presents a programming system, called speculative nondeterminism,
for real time, distributed programming. The programs access shared
state and supports speculation by allowing multiple strategies to move
forward at once, each executing in its own “virtual world.” The paper
describes an implementation of the system (in Erlang) and gives some small
examples to demonstrate the it's use on concurrency control problems
from the literature: Flight Reservations, Stock Trading, and Dining
Philosophers. The results show the (expected) exponential growth in
the state space and the ability to terminate (exit) executions based on
external input.

          >>> Evaluation <<<

This paper addresses important problems in systems with concurrency,
namely how to handle nondeterminism and speculative execution.
The paper is based on ideas from Linda and Prolog, and is missing the
context and related work of all of the more recent work, e.g.,
lineariable data structures, serializability, transactional memory,
etc. While the system combines some useful ideas to handle
concurrency and real-time behavior, the work does not have a major
innovation or surprising insight.

The implementation and experimental results are not very surprising,
and the conclusions rather weak -- the exit mechanism used to
terminate work based on external input are effective in avoiding
unnecessary computation. Some evidence that the proposed mechanisms
are substantially better than existing (real world) systems, would
strengthen the paper substantially.
