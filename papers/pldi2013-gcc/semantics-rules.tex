\begin{figure}[ht!]
\centering
% TODO: use a tabular{cr} to format better
\flushright\fbox{Entrance transition: $T\|a\Longrightarrow T'$}
\[
  \tag{\sc Entrance1}\label{rule:entrance1}
  \langle A,D,S\rangle \| a \Longrightarrow \langle A+[a],D,S\rangle
\]
\[
  \tag{\sc Entrance2}\label{rule:entrance2}
  T_1\oplus_k T_2 \| a \Longrightarrow (T_1 \| a)\oplus_k (T_2 \| a)
\]
\flushright\fbox{Tree transition: $T\To T'$}
\[
  \tag{\sc Swap}\label{rule:swap}
  T_1\oplus_k T_2 \To T_2\oplus_k T_1
\]
\[
  \tag{\sc DataOp}\label{rule:dataop}
  \frac
  {A[k]=d.e:f \qquad D\vdash d \qquad \langle t,D'\rangle=\psi(d,D)}
  {\langle A,D,S\rangle \To \langle A[k\mapsto t.e:f], D', S\rangle}
\]
\[
  \tag{\sc Choice}\label{rule:choice}
  \frac
  {\begin{matrix}
    A[k]=(e_1\oplus e_2).e:f \\
    T_1=\langle A[k\mapsto e_1.e:f],D,S\rangle \\
    T_2=\langle A[k\mapsto e_2.e:f],D,S\rangle
   \end{matrix}}
  {\langle A,D,S\rangle \To T_1\oplus_k T_2}
\]
\[
  \tag{\sc Cm}\label{rule:cm}
  \frac
  {A[k]=\cm.e:f}
  {\langle A,D,S\rangle\oplus_k T \To \langle A[k\mapsto e:f],D,S\rangle}
\]
\[
  \tag{\sc Cu}\label{rule:cu}
  \frac
  {A[k]=\cu.e:f}
  {\langle A,D,S\rangle\oplus_k T \To T}
\]
\[
  \tag{\sc Exit1}\label{rule:exit1}
  \frac
  {A[k]=\exit.e :f \qquad s=\langle k,f(D)\rangle}
  {\langle A,D,S\rangle \To \langle A[k\mapsto\exiting],D,S\cup\{s\}\rangle}
\]
\[
  \tag{\sc Exit2}\label{rule:exit2}
  \frac
  {\begin{matrix}
    \forall w\in leaves(T): exiting(w,k) \land v = exitv(w,k)
   \end{matrix}}
  {T \To exit(T,k)}
\]
\[
  \tag{\sc Collapse}\label{rule:collapse}
  \frac
  {\begin{matrix}
    w \in leaves(T) \\
    \forall k: exiting(w,k) \lor exited(w,k)
   \end{matrix}}
  {T \To w}
\]
\flushright\fbox{Local computation transition: $e\computes e'$}
%\begin{align*}
\[
\begin{array}{llll}
  e &\computes op.e' \hspace*{5mm} &
  e &\computes \epsilon \\
  t.e &\computes e' &
  e_1.e_2 &\computes e_1'.e_2 \\
\end{array}
\]
%%  \epsilon.e &\computes e
%\end{align*}
\flushright\fbox{Helper functions}
\begin{gather*}
  \frac
  {T = T_1\oplus_k T_2}
  {leaves(T) = leaves(T_1)\uplus leaves(T_2)} \\
  leaves(w) = \lbb w\rbb \\
  \frac
  {w=\langle A,D,S\rangle \qquad \langle k,v\rangle\in S}
  {exitv(w,k) = v} \\
  \frac
  {w=\langle A,D,S\rangle}
  {exiting(w,k) = (A[k]=\exiting)} \\
  \frac
  {w=\langle A,D,S\rangle}
  {exited(w,k) = (A[k]=\exited)} \\
  \frac
  {T = T_1\oplus_i T_2}
  {exit(T,k) = exit(T_1,k)\oplus_i exit(T_2,k)} \\
  \frac
  {w=\langle A,D,S\rangle}
  {exit(w,k) = \langle A[k\mapsto\exited],D,S\rangle}
\end{gather*}
\caption{Semantics of the Speculation Language.
$[\dots]$ denotes a list,
$A[k]$ is the $k$-th element in list $A$, and
$A[k\mapsto x]$ denotes the updating of the $k$-th element to $x$.}
\label{fig:semantics}
\end{figure}

\subsection{Semantics}\label{sec:semantics}

The semantics of the speculation language is 
given in \figref{fig:semantics}. 

\paragraph*{Entrance}
New agents can dynamically enter the system at any time.
\ref{rule:entrance1} and \ref{rule:entrance2} the addition of
a new agent $a$ to the system (denoted $\|$). The Plus sign ($+$) 
denotes list concatenation. The whole tree is recursively traversed and $a$ is appended to the agent list in every world. 

\paragraph*{Choice Symmetry}
\ref{rule:swap} shows that the two branches of an interior node in the tree are treated equally.

\paragraph*{Data Operation}
An agent wants to execute operation $d$ on the data store $D$
(see \ref{rule:dataop}).
This transition first has to meet condition $D\vdash d$. 
The effect of $d$ on data store $D$ is defined by
the transition function $\psi$ in the data model and it only
affects the current world having store $D$
without affecting other worlds in the tree.
The result of $d$ is denoted is $t$ and provided to the remaining local 
computation $e$ as a parameter (denoted by the special syntax $t.e$). 
$t.e$ is not processed by the speculation framework, but 
activates the local computation $e$ and will eventually transform to another 
local computation $e'$ (i.e. $t.e\computes e'$). 

\paragraph*{Local Computation}
The local computation transition is simply a placeholder for
the semantics of the actual computation in the host language.
As that is orthogonal to our semantics, the details are left
unspecified. There is one special operation, $t.e$, which applies
the result of a data operation $t$ to some local computation $e$.
For example, it might be to store $t$ in a variable in the host language.
% \KZ{The following may need to be changed:\\
% We shall omit the details of the language in which 
% local computations are expressed and just assume that
% there exist a local computation transition $\computes$.
% From the perspective of the speculation framework, 
% the only thing that matters is the operation $op$ 
% produced by a local computation. 
% As shown in \figref{fig:semantics}, 
% a local computation $e$ transforms to $op.e'$ to 
% execute $op$ under the framework, or to $\epsilon$ to 
% finish execution. 
% After a data operation which reads something from the data store,
% a data item $t$ in the store is returned to the local computation $e$, 
% and further transforms to a new local computation $e'$, which is 
% $e$ parameterized by $t$. 
% $e_1.e_2$ denotes sequential execution of $e_1$ and $e_2$. 
% After $e_1$ transforms to $\epsilon$, $e_2$ starts execution 
% ($\epsilon.e\computes e$).
% }

\paragraph*{Choice and Commit}
Speculative nondeterminism provides for the creation and subsequent
pruning of choices. 
\ref{rule:choice} fires if an agent is reduced to a choice $(e_1\oplus e_2).e$, 
and it consumes the choice construct in the agent to split the current world into two
(i.e. $T_1$ and $T_2$). 
Section \ref{sec:commit} discusses further the ramifications of commit,
here, we start with first describing what the commit rules do.
When the $k$-th agent executes $\cm$ in a leaf world of the tree structure, 
as shown in rule \ref{rule:cm}, the other side of the choice (i.e. $T$) is pruned
only if the current choice node is $\oplus_k$. 
Similarly, $\cu$ is used where the agent wants to explicitly gives up the current choice branch,
so the current side of the choice is pruned, 
as shown in rule \ref{rule:cu}. 
$\cm$ and $\cu$ are symmetric and both of them are {\em commit} operators.
Commit of the $k$-th agent can only be executed in a world with $\oplus_k$ as its parent,
and it is blocking when the parent node is not $\oplus_k$.
%which makes the commit more localized and less aggressive. 
% This form of commit semantics is therefore known as {\em localized commit}.
%With this commit semantics, it only affects a small fraction of the whole tree. 
%Also it is possible to make pruning decisions locally, which makes it efficient. 

\paragraph*{Exit}
In general, a single agent will have many versions of itself executing
in all the multiple virtual worlds.
Thus, if it were simply to exit from all the worlds on the first
$\exit$ operation, this could lead to some form of data inconsistency.
We deal with this using the exit function $f$ specified by each agent which
allows an agent-specific consistency condition to be used.
Note that different agents may be interested in different aspects of the data store. 
When an agent exits, all the worlds should look the same from the perspective of that agent. 
However, another agent may not consider the worlds to be the 
same since it can have a different exit function. 
This also means that an agent properly exiting is only achieved when
the consistency requirement is obtained.

Rule \ref{rule:exit1} and \ref{rule:exit2} shows the exit semantics. 
\ref{rule:exit1} shows the case when an {\em instance} 
of the $k$-th agent reaches $\exit$ in a world. 
In this case, the exit function $f$ is applied to the current data store $D$ and a {\em snapshot} 
is created and added to $S$. 
 
The exit function $f$ takes a data store as input, and returns an integer as the evaluated result. 
The data store is just the one associated with the current world. 
According to the data store, the exit function is expected to produce an integer 
which can be a 0/1 indicator, a heuristic value, or an encoding of more complicated mathematical objects. 
For example, in the simplest case, $f(d)\equiv 1$ allows the agent to exit without any condition 
as long as it completes execution of all the operations in the program. 
The ability to return an integer provides more flexibility and enables 
complex exiting logic to be embedded in this exit function.

While taking a snapshot, 
the agent in that world switches to a special state $\exiting$.
\ref{rule:exit2} checks all the worlds in the tree. Only if (i) the $k$-th agent has 
switched to $\exiting$ state in all the worlds, and (ii) the exit value $v$ of the $k$-th agent 
is {\em identical} across all the worlds, 
then the $k$-th agent can exit from the worlds at the same time. 
For \ref{rule:exit2}, the exit value $v$, which can be thought of as the return value from
the speculative computation, will be eventually provided to 
a local computation $\tilde e$
which is completely outside the system of virtual worlds, 
and has no more speculation and data store operations. 
The idea of this type of consistent exit across all worlds is analogous
algebraic factorization, i.e.
$ab + ac = a(b+c)$.

\paragraph*{Collapse}
Note that commit is optional in an agent program, so the agents can 
let the tree expand without pruning, and finally leave the tree 
without reducing to one world. 
Therefore some agents may never exit due to the inconsistency of some worlds, 
even if all the agents have finished execution.
\ref{rule:collapse} handles this case 
to let these agents exit as well as to reclaim system resources. 
The system could employ a global collapse rule to pick any world where 
all agents have completed execution and reduce the tree to one world.
For \ref{rule:collapse}, the exit value for every agent $k$ is also returned in this way.
$\tilde e$ can make use of the exit value to extract what the agent concerns. 
%\KZ{Need to say exit is implicit if it's not added to the program?}

\paragraph*{Helper Functions}
We also define a set of helper functions to simplify the semantics. 
\begin{description}
\item[$leaves(T)$] returns a multi-set of the leaf worlds in tree $T$. 
\item[$exitv(w,k)$] retrieves the exit value, i.e. the evaluation result of the exit function, of the $k$-th agent in world $w$.
\item[$exiting(w,k)$] is a predicate indicating whether the $k$-th agent in world $w$ is in the special state of $\exiting$.
\item[$exited(w,k)$] is a predicate indicating whether the $k$-th agent in world $w$ is in the special state of $\exited$.
\item[$exit(T,k)$] switches the $k$-th agent in all the worlds in $T$ to the special state of $\exited$.
\end{description}
