\subsection{Syntax}\label{sec:syntax}

% \RY{explain syntax, examples and then semantics. The semantics needs to
% be more detailed in the explanation and motivate the definitions etc.,
% e.g. what does commit do, what is the effect of this particular commit.
% What does exit do - why not just exit immediately. Also commit and
% exit are not immediate, again this is because of what they do.
% The local transitions part seems messy with things which are not defined
% but used. \\
% Erlang style notation has to be briefly explained. Use the first
% 2 rules in fly for this.
% }

\begin{figure}
\centering
\begin{eqnarray*}
     \text{Agent } a & := & p:f ~~|~~ \exiting ~~|~~ \exited \\
   \text{Program } p & := & e ~~|~~ op.e ~~|~~ t.e ~~|~~ e_1.e_2 ~~|~~ \epsilon \\
\text{Operation } op & := & d ~~|~~ e_1\oplus e_2 ~~|~~ \cm ~~|~~ \cu ~~|~~ \exit \\
                     &    & \\
      \text{Tree } T & := & w ~~|~~ T_1\oplus_k T_2 \\
     \text{World } w & := & \langle A,D,S\rangle \\
    \text{Agents } A & := & [] ~~|~~ [a_1,\dots,a_m] \\
 \text{Snapshots } S & := & \emptyset ~~|~~ \{s_1,\dots,s_n\} \\
  \text{Snapshot } s & := & \langle k,v\rangle
\end{eqnarray*}
\caption{Syntax and Runtime Data Structures.
$f:\allstore\to\nat$ is a exit function.
$e$ denotes a local computation,
$t\in\alltype$ is the input for the local computation,
and $\epsilon$ is the end of a local computation.
Dot (.) in $p$ means sequencing.
$d\in\allop$ is a data operation while $D\in\allstore$ is a data store.
$k\in\nat$ is the identifier of an agent.
$v\in\nat$ is an exit value of an agent.
}\label{fig:syntax}
\end{figure}

The syntax of the language for speculation is 
formally described in Figure \ref{fig:syntax}. 
The idea is that we have two languages, one which deals with the speculative
computation, the other is a host language where the speculation constructs
are embedded within.
The host and speculation language are conceptually orthogonal though
in practice one would want them to be closer.
In our syntax, an agent consists of a program $p$ and an exit function $f$. 
In the syntax in Figure \ref{fig:syntax}, $e$ is used to denote a language
computation in the host language. Since the host language is arbitrary, we
only define a meta syntax here\footnote{
The syntax here is similar to \cite{Ciancarini95} which gives a semantics
of Linda embedded in a host language.
}
in that $e$ is meant to evolve to some other
local computation $e'$ outside our semantics.
We use $\epsilon$ to denote the end of such a local computation. 
There is a special syntax $t.e$ where $t$ is intended to be the
result of the data operation $d$ ($t$ is the result of transition function $\psi$).
The meaning is that $e$ is intended to consume the result $t$, which overloads,
the dot symbol.\footnote{
This is because $d$ is defined in the data model but divorced from the host
language, thus, there would be something in the host language to deal with
the result $t$.
}
During runtime, an agent can also switch to special states $\exiting$ and $\exit$, 
which will be explained in Section \ref{sec:semantics}. 

The top-level runtime data structure is the tree of worlds,
while a world is a triple of a list of agents $A$, 
a data store $D$, and a set of snapshots $S$. 
A snapshot $s=\langle k,v\rangle$ is used in exit 
where $k$ denotes the $k$-th agent and $v$ is the exit value. 
%

\begin{figure}[tb]
\begin{lstlisting}[caption={Speculation Example using Tuple Space. 
We use \texttt{(...)} to denote tuples and
$\lambda x.\varphi(x)$ denotes a condition for $\In$ and $\Rd$ on the specific field in a tuple, where $\varphi$ is the condition expression such as ``$x\texttt{=ac}\lor x\texttt{=cb}$'' which means $x$ is equal to either {\tt ac} or {\tt cb}.},label=lst:ts-example]
|$\In$|(ticket, ab)
|$\oplus$|
(|$\In$|(ticket, |$\lambda x.x\texttt{=ac}\lor x\texttt{=cb}$|) = (ticket, X)
 if X = ac
   |$\In$|(ticket, cb)
 else
   |$\In$|(ticket, ac))
\end{lstlisting}
\end{figure}

We use the tuple space data model throughout this paper 
due to its simplicity and expressive power.
In order to explain further, we rewrite Listing \ref{lst:intro-speculate}
concretely using the tuple space data model and show it in Listing \ref{lst:ts-example}.
%
We use this style of host language from now on to 
demonstrate local computations as well as to embed speculation primitives, where
(i) identifiers starting with lowercase letters are symbol literals,
(ii) identifiers starting with uppercase letters are variables,
(iii) equal sign (\texttt{=}) denotes pattern matching and binding,
(iv) variables are immutable after binding,
(v) $\lambda x.\varphi(x)$ is a first-class anonymous function 
taking $x$ as the parameter and evaluating $\varphi(x)$ as 
the result of the function on calling. 
%\KZ{But what's $x$? Its type?} 
Such features are derived from functional languages such as Haskell and Erlang. 
The choice of host language is primarily for ease of presentation,
since the speculative nondeterminism framework is independent of 
the host language and local computations.
However, we also have a prototype implementation in Erlang which also uses
Erlang as the host language, thus our syntax is most similar to Erlang.
