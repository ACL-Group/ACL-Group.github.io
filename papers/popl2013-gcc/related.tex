\section{Related Work}\label{sec:related}

Our previous work \cite{Jaffar05:coma,JaffarYZ07}
offers the preliminary and early ideas of speculation. 
This paper differs in a number of ways: 
(i) we propose a simpler and more practical language that is geared
toward actual implementation;
(ii) the new commit operator is more conservative and hence reduces
the chance of removing potential solutions;
(iii) we deal with agents exiting the system;
(iv) we formalize the operational semantics in 
a complete calculus which allows us to reason about the system;
and (iv) most importantly, we demonstrate the viability of speculative
nondeterminism with a prototype which works with imperative languages 
like C/C++.
%
%This paper extends that idea by introducing the exit semantics and new
%commit semantics. It also generalizes the notion of data store into a flexible
%data model which is separate from the main operational semantics of 
%speculative nondeterminism. We then describe the semantics in a complete
%calculus which allows us to formally reason about the framework. 
%Furthermore, we have implemented the framework
%as a C library and give the comprehensive evaluation results on 
%benchmark programs. 

The most closely related work to this paper is Shared Prolog \cite{BrogiC91},
which is in the family of concurrent
logic programming languages \cite{Shapiro89:CLP-survey}. Other related
languages include Concurrent Prolog \cite{ShapiroT83:ConProlog} and 
Guarded Horn Clauses \cite{Ueda85:guarded}. These languages extend 
traditional logic programming languages with some form of 
guards \cite{Dijkstra75:guarded} which serves as a synchronization
construct for concurrency. 
% synchronize the concurrent accesses to shared variables. The OR-parallelism
% in logic programs, that is, the parallelism exposed by matching 
% multiple goals in the unification
% is analogous to the exclusive choices in our proposed framework. 
The guards function intuitively as read-only goals 
to choose between alternative sequential logic programs. 
The key difference is while there may be
nondeterministic choices (OR-parallelism) in a sequential program,
these choices are not exposed to the other concurrently executing
logic programs and hence there's no combinatorial choices 
which is the key artifacts of speculative nondeterminism.
% and do not update the
% But in all
% these languages, only guards are executed in parallel (or in separate worlds
% in our terminology), and guards are read-only goals and do not update the
% variable store. 
Shared Prolog uses the blackboard data model to implement the guards.
These guards only read or remove tuples from
the blackboard but not add tuples. This model is designed for
collaborative applications in which agents share tasks,
but is less conducive to a competitive
environment where speculative nondeterminism is more
suitable. 
Our implementation of the data model is
inspired by Linda \cite{GelernterC92}, 
a well-known blackboard model. 
Later work on multiple tuple spaces in Linda \cite{Gelernter89multiple}
is also related to the multi-world model in our framework. 
However, speculative nondeterminism can be applied to 
a general data store, and not just blackboards.

Deep guards in the constraint programming language 
Oz \cite{SchulteSW94, Mehl:diss}
are also similar to the concurrent logic programming languages.
It supports local computation spaces with
monotonic constraint stores where all local
effects only become globally visible at the time of commit. 
Our framework, in contrast, allows arbitrary updates to the
data store where agents concurrently interact with one another 
both inside and outside choices.
Viewing the operations before the commit as a guard, 
we allow updates in the guard which is compatible with regular 
imperative programming languages while monotonic stores are not.

% we have generalized the data store to use 
% a variety of well-known data model, be it tuple space, key-value store, 
% relational database or logic programs.

The idea of speculation has been used in programming languages
in more restricted contexts. 
% In sequential code, speculation is used to increase 
% instruction level parallelism for performance either at the micro-architectural
% level of the CPU or in conjuction with compilers.
%
% In programming languages and systems, speculation is synonymous 
% to optimistic/opportunistic/eager evaluation.
Language constructs such as {\tt future} in Multilisp 
\cite{Osborne1990:multilisp} and Java \cite{WelcJH05}
and speculative composition/iterations in C\# \cite{PrabhuRV10}
are also examples of programmable speculative parallelism.
As Osborne rightly pointed out \cite{Osborne1990:multilisp}, 
speculation requires: a means to
control computation to favor most promising ones; and a means to
abort computation and reclaim the resources. 
The commit and exit semantics in our framework does this in general way
for arbitrary agent programs.
Recent versions of Glasgow Haskell Compiler support speculative execution with 
an abortion mechanism to back out in case of a bad choice called 
optimistic execution \cite{EnnalsJ03:optimisitic}.
In composable memory transactions (CMT) \cite{Harris05:CMT}, 
the {\tt orElse} construct specifies several alternatives 
in memory transactions.
However, our framework is more general, dealing with {\em open} agents
with arbitrary imperative programs, concurrency, reasoning with choices
and also allows real-time programming.
% none of the above work deals explicitly with the multiplicity 
% of possible worlds in an {\em open} and real-time agent programming context. 
Speculation has been used 
for extracting instruction-level or thread-level parallelism 
\cite{Hammond1998:DSS}. 
Here, idle hardware units are used to execute code that might be useful
later. In case the speculation is wrong, hardware support is need to
cancel the side effects. 
One form of such speculation is known as
{\em eager execution} \cite{Uht1995:DEE} where both sides of 
a conditional ({\tt if-then-else}) 
is executed before the condition predicate is evaluated. 
However, these forms of speculation are in restricted contexts and
are usually intended for performance rather than expressivity.
% This form of prediction is akin to the combinatorial world model used in
% speculative nondeterminism. 
% However, compiler-based speculation is completely 
% transparent to the programmer 
% and the compiler or the system decides when and how to speculate.
% Furthermore, commit and exit semantics provided in our framework
% gives the programmer additional control over the behavior of speculation. 

Nondeterminism has long been studied in programming languages.
While there are many forms of nondeterminism, we can characterize two classes,
don't know nondeterminism and don't care nondeterminism.
Guarded languages such as Dijkstra's guarded commands \cite{Dijkstra75:guarded},
CSP \cite{Hoare85:CSP} and the committed choice languages mentioned earlier, 
fall into the don't care class.
Logic Programming or Constraint Programming languages, on the other hand,
are more concerned with don't know since the objective is to find the
solution to a program which involves combinatorial reasoning.
Speculative nondeterminism also deals with don't know nondeterminism but
adds concurrency and interacting agents into the mix.
Since we have concurrency, we can also express don't care nondeterminism.
The cut ({\tt !}) mechanism in Prolog \cite{DantsinEGV01} is related to our commit
operator as both prune the solution space.
Unlike cut, commit is more conservative and do not always prune.

% Nondeterminism \cite{Floyd67, Johansen67, BroyW81} long exists in 
% computer programming. 
% One of the earliest nondeterministic languages is Dijkstra's 
% guarded commands \cite{Dijkstra75:guarded}. Other languages
% such as Datalog \cite{KrishnamurthyN88}, 
% logic languages \cite{SaccaZ90, GiannottiPSZ91} and functional languages 
% \cite{SondergaardS92} all have implicit or explicit nondeterminism.
% There are roughly three kinds of nondeterminism 
% \cite{Hoare85:CSP, Broy86, BodikCGKTBR10}: 
% angelic nondeterminism, demonic nondeterminism and erratic nondeterminism.
% Speculative nondeterminism is a kind of erratic nondeterminism. 
% We also deal with what we call open agents which is realistic in
% a real world environment where one does not have control over agents by others.
% It differs
% from these sequential languages in that it is a concurrent programming
% model for open agents.
% Choices in logic programs 
% The choices in logic programs are implicit and they are not exclusive
% because the evaluation of logic program can return all solutions.
% However, in Prolog, a cut (!) predicate \cite{Billaud90:cut} 
% can be placed in the program to limit the scope of backtracking 
% and thus the solution space, in much the same spirit as 
% the commit operator in our framework.

Finally, the multiple-world model is also related to
multiversion concurrency control (MVCC) 
\cite{BernsteinG83,BestavrosB94} in databases. 
MVCC keeps multiple versions of a database in the sense that each user has
a unique view of the database, and updates are not visible to other users
until the transaction has committed. 
% The advantage of this is no locks or mutex is required, 
% but instead data items are tracked by their read or write timestamps. 
Transactions that are deemed invalid are discarded which is similar
to pruning worlds in our framework.
Implementations of transactional memory also use this idea.
While most of the work in this space are in
concurrency control, this paper proposes a 
{\em programmable} framework for a new kind of nondeterminism.

% A variant of MVCC is long-lived database transactions such as
% Sagas \cite{Garcia-Molina87:sagas} which expose updates among 
% each other and therefore may lead to
% conflicts at commit time. Such conflicts can only be resolved with rollbacks.
% In case of Sagas, rollbacks may involve compensating actions in several
% transactions which may or may not be possible.

%
%
%\subsection{Previous Work}
%GCC \cite{JaffarYZ07}
%
%\subsection{OR-Parallelism in Logic Programming}
%OR-Parallelism (dependent): MUSE and ACE systems
%
%Shared Prolog \cite{BrogiC91}
%
%Concurrent Prolog \cite{ShapiroT83:ConProlog}
%
%Transaction Logic \cite{Bonner93:TransactionLogic}
%
%Deep guards in Oz \cite{SchulteSW94, Mehl:diss}
%
%\subsection{Speculation in Programming Languages}
%
%Speculation in Parallel Programming \cite{PrabhuRV10}
%
%Multi-Lisp \cite{Osborne1990:multilisp}
%
%Speculative Haskell \cite{EnnalsJ03:optimisitic}
%
%Transactional memory \cite{HerlihyM93:trans-mem}
%
%\subsection{Speculation in compilers and systems}
%
%Speculative Concurrency Control \cite{BestavrosB94,BestavrosB95}
%
%Optimistic transaction and rollbacks
%
%Sagas \cite{Garcia-Molina87:sagas} 
%
%MVCC in DB
%
%\subsection{Data Model}
%Linda \cite{GelernterC92}
%
%Multiple tuple spaces \cite{Gelernter89multiple}
%
%Other coordination models \cite{Papadopoulos98}

