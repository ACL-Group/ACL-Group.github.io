\documentclass{acm_proc_article-sp}
\usepackage{url,color}
\usepackage{subfigure}
\usepackage{alltt}
\usepackage{epsfig}
\usepackage{epstopdf}
\usepackage{enumerate}
%\renewcommand{\rmdefault}{ptm}
%\usepackage{mathptmx}
\newcommand{\KZ}[1]{\textcolor{blue}{[KZ:#1]}}
\begin{document}
\numberwithin{equation}{section}
% first the title is needed
\title{A Verilog Precompiler for Interactive Optimization of IP Core Design}
%
%
\numberofauthors{5} % in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor
Donghua Wang\\
\affaddr{Shanghai Jiao Tong University}\\
\affaddr{Shanghai, P.R. China}\\
\affaddr{+861361644646}\\
\email{alex\_sjtu@sjtu.edu.cn}
% 2nd. author
\alignauthor Biman Tang\\
\affaddr{Shanghai Jiao Tong University}\\
\affaddr{Shanghai, P.R. China}\\
\affaddr{+8615267144434}\\
\email{every.e1va@sjtu.edu.cn}
% 3rd. author
\alignauthor Jin Sha\\
\affaddr{Shanghai Jiao Tong University}\\
\affaddr{Shanghai, P.R. China}\\
\affaddr{+8613681832476}\\
\email{shajin0000@sjtu.edu.cn}
\and % use '\and' if you need 'another row' of author names
% 4th. author
\alignauthor
Kenny Q. Zhu\\
\affaddr{Shanghai Jiao Tong University}\\
\affaddr{Shanghai, P.R. China}\\
\affaddr{+86139182722740}\\
\email{kzhu@cs.sjtu.edu.cn}
% 5th. author
\alignauthor Yibo Fan\\
\affaddr{Fudan University}\\
\affaddr{Shanghai, P.R. China}\\
\affaddr{+8613764271981}\\
\email{fanyibo@fudan.edu.cn}
}
%%%%
\maketitle
\begin{abstract}
SV+ is an interactive compiler that makes circuit designer do trade-offs 
between resource consuming and time cost easily, without rewriting the 
source code. A set of succinct SV+ syntaxes are proposed in this work. 
They can be used to embed with HDLs\cite{intro:HDL} to describe the 
re-configurable parts of a circuit. Users have chances to select 
optimization options during the compiling process. The compiler 
generates Verilog RTL codes, depends on these choices. And for different
optimization choices, the circuits vary in architectures besides 
in time and resource. SV+ syntaxes can describe reconfigurable circuit
structures in mathematical or functional level, so designers are 
liberated from putting much effort on concerning about module scheduling
and wire connection. Unlike other circuit compilers, for example DFT 
compiler\cite{GNordin:FFT}, that work on single kind of algorithms,
SV+ syntaxes can be used in a range of Verilog programs as long as 
there are any reconfigurable structures been explored in SV+ system.
\end{abstract}
\section{Background and Motivation}
Hardware description language (HDL)\cite{intro:HDL} based IP synthesis has been the 
industry standard in recent years.
However, it has a number of problems.
First, Verilog and VHDL are so low level that they are often compared to assembly languages
in terms of programmability.
Secondly, while most HDLs offer design libraries of basic building blocks,
these are largely limited to the hardware circuit level, and are often inadequate for programming
large, complex but common algorithms such as those used in cryptography and image processing.
Last, because HDLs do not offer the 
capability of high level abstraction, it is not easy to reconfigure the functionality of an
existing design. For example, for a given design of an AES\cite{AES} algorithm, if the user prefers
to trade die space for speed, a common approach is to unroll a loop a number of times
and execute it in parallel within a clock cycle. Such unrolling cannot be achieved
in Verilog without substantial code change.
\section{Contributions}
In our work, we proposed some higher function\cite{highorderfunction} like syntaxes, $map$, $fold$ and $forloop$ that can be embedded with Verilog to describe reconfigurable structures in hardware circuits. Unlike existing HDL languages that may describe circuit in behavior level at most, SV+ depicts the mathematical computation meaning of some circuits. What's more, these syntaxes can be embedded with traditional Verilog code. An interactive precompiler was constructed to translate SV+ program into Verilog RTL code. With the precompiler, the designer gets chances to do circuit optimizations during the compiling process. Basically, I think our contributions include:
\vspace{-4ex}
\begin{itemize}\itemsep2pt \parskip0pt \parsep0pt
\item Mathematical meaning has higher abstract level than behavior description. 
Thus SV+ partly makes it easier to design some circuits, especially 
complex ones. Designers don't have to concern too much about low level details, such as 
wire connection and module schedule.
\item SV+ precompiler interacts with the user while compiling when optimization opportunity
been found. So that people even don't have sound knowledge on hardware circuit are 
able to produce, in some degree, nice designs. 
\item For different live optimization choices, we can gain a set of circuits that vary in 
architecture, which is not just trivial changes, as well as resource consuming and 
time cost. This really make good sense if the user wants to seek trade-offs between 
circuit space and running speed. 
\item No modification on the source code is needed if the user would like to synthesis a
different IP core. And for every re-configurable circuit structure, user has some 
options on optimizing it. So, when it comes to several such structures in a design, the 
number 
of IP cores we can gain is significant. We may get twice the result with half the effort
\end{itemize}
\section{Results}
We carried out a set of observations on the SV+ system. Firstly, we compared a SV+ program with the one in Verilog, to show the advantage of SV+ in describing reconfigurable structures. Secondly, a cluster of implementations of AES algorithm generated from one copy of SV+ code were simulated, synthesized and mentioned.
\subsection{SV+ code \& Verilog}
Here we discuss the code that compute equation\eqref{eq:code} in Verilog left side) and SV+.
\begin{equation}
out = in{<<}s3{+}in{<<}s2{+}in{<<}s1{+}in{<<}s0 
\label{eq:code}
\end{equation}
%\vspace{6ex}
\hrule
\vspace{-3ex}
\begin{verbatim}
Verilog:                 SV+
1. module scm(ports);   | module scm(ports);
2.  ...(declares)       |   ...(declares)
3.  reg[31:0] sum;      |   reg[31:0] sum;
4.  reg[31:0] tmp;      |   assign out = sum;
5.  always@(posedge clk)|   always@(posedge clk)
6.  if(rst_i)           |   if(rst_i)
7.    sum <= 0;         |     sum <= 0;
8.  else if(s_i3)       |   else if(fold_i)
9.    temp <= in << s3; |     fold(sum,in,s3,
10. else if(s_i2)       |      s2,s1,s0);
11.   temp <= in << s2; | endmodule
12. else if(s_i1)       | 
13.   tmp <= in << s1;  | 
14. else if(s_i0);      | 
15.   tmp <= in << s0;  |
16. else if(add_i)      |
17.   sum <= sum + tmp; |
18.endmodule            | 
\end{verbatim}
\vspace{-3ex}
Literally, the main difference  is the usage of a $fold$ statement(line 9) in the SV+ 
program. However, with deep thinking on these two descriptions we could recognize that:
\vspace{-3ex}
\begin{itemize}\itemsep2pt \parskip0pt \parsep0pt
\item[$\diamond$] In Verilog, designer needs to be careful to which $tmp$ should connect, in line 9 and 11.
\item[$\diamond$] If we want to compute the shift-summation of more variables, for example $s3,s2,s1,s0$,sevral 
lines of boilerplate code should be added to the Verilog program. And for SV+ program, small 
changes to $fold(sum,in,$ $s5,s4,s3,s2,s1,s0)$ could do.
\item[$\diamond$] Most important, if we want to use more resources to speed up the computation, rewriting on 
the 
Verilog is unavoidable, but SV+ code can remain unchanged. The compiler could see the 
trade-offs and do it. 
\end{itemize}
\subsection{Area and Timing Measuring Result of AES}
15 kinds of optimizations choices for AES\cite{AES} are explored by SV+ system. The synthesis result of these implementations are vary in architectures as well as in resource consuming and time cost. We synthesized these RTL descriptions in Synopsys using TSMC 0.18$um$ standard cell library. Table \ref{xxxx} shows the main measuring dimensions of these circuits.
\begin{table}[thbp]
\centering
\begin{tabular}{|l|l|l|}\hline
Conf(s) & Gates & Cycles \\ \hline
1,1 & 4004 & 218 \\ \hline
1,2 & 4314 & 200 \\ \hline
1,4 & 4824 & 191 \\ \hline
2,1 & 4398 & 138 \\ \hline
2,2 & 4742 & 120 \\ \hline
2,4 & 5164 & 111 \\ \hline
4,1 & 5057 & 98 \\ \hline
4,2 & 5350 & 80 \\ \hline
4,4 & 5828 & 71 \\ \hline
8,1 & 6599 & 78 \\ \hline
8,2 & 6875 & 60 \\ \hline
16,1 & 7315 & 51 \\ \hline
16,2 & 9310 & 68 \\ \hline
16,4 & 9686 & 50 \\ \hline 
16,4 & 10069 & 41 \\ \hline
\end{tabular}
\caption{Area and Cycles of Automated Generated AES Implementations}
\label{xxxx}
\end{table}
Where, configurations are the number of sub-modules sbox and mixcolumnx used in AES design. We could see that, configuration with the most modules has 2.5 times of gates number of that with fewest modules and 20% of the cycles. Thus, the reconfigurations do make sense, since users can get considerable trade-offs between space and time.
\bibliographystyle{abbrv}
\bibliography{richip} 
\end{document}
